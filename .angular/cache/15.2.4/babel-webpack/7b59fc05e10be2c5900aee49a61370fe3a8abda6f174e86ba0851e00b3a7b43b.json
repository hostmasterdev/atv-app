{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Optional, SkipSelf, Inject, Injectable, inject, Injector, ViewContainerRef, EventEmitter, NgZone, ElementRef, Input, Output, ContentChildren, NgModule } from '@angular/core';\nimport { Overlay, OverlayConfig, STANDARD_DROPDOWN_BELOW_POSITIONS, STANDARD_DROPDOWN_ADJACENT_POSITIONS, OverlayModule } from '@angular/cdk/overlay';\nimport { UP_ARROW, hasModifierKey, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, TAB, ESCAPE } from '@angular/cdk/keycodes';\nimport { startWith, debounceTime, distinctUntilChanged, filter, takeUntil, mergeMap, mapTo, mergeAll, switchMap, skip } from 'rxjs/operators';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { Subject, merge, fromEvent, defer, partition } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { InputModalityDetector, FocusKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { _getEventTarget } from '@angular/cdk/platform';\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\r\n */\nclass CdkMenuGroup {}\nCdkMenuGroup.ɵfac = function CdkMenuGroup_Factory(t) {\n  return new (t || CdkMenuGroup)();\n};\nCdkMenuGroup.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuGroup,\n  selectors: [[\"\", \"cdkMenuGroup\", \"\"]],\n  hostAttrs: [\"role\", \"group\", 1, \"cdk-menu-group\"],\n  exportAs: [\"cdkMenuGroup\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: UniqueSelectionDispatcher,\n    useClass: UniqueSelectionDispatcher\n  }])]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuGroup, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuGroup]',\n      exportAs: 'cdkMenuGroup',\n      standalone: true,\n      host: {\n        'role': 'group',\n        'class': 'cdk-menu-group'\n      },\n      providers: [{\n        provide: UniqueSelectionDispatcher,\n        useClass: UniqueSelectionDispatcher\n      }]\n    }]\n  }], null, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** Injection token used to return classes implementing the Menu interface */\nconst CDK_MENU = new InjectionToken('cdk-menu');\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** Injection token used for an implementation of MenuStack. */\nconst MENU_STACK = new InjectionToken('cdk-menu-stack');\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\nconst PARENT_OR_NEW_MENU_STACK_PROVIDER = {\n  provide: MENU_STACK,\n  deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || new MenuStack()\n};\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\nconst PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER = orientation => ({\n  provide: MENU_STACK,\n  deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || MenuStack.inline(orientation)\n});\n/** The next available menu stack ID. */\nlet nextId$2 = 0;\n/**\r\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\r\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\r\n * from the `empty` observable specifying the next focus action which the listener should perform\r\n * as requested by the closer.\r\n */\nclass MenuStack {\n  constructor() {\n    /** The ID of this menu stack. */\n    this.id = `${nextId$2++}`;\n    /** All MenuStackItems tracked by this MenuStack. */\n    this._elements = [];\n    /** Emits the element which was popped off of the stack when requested by a closer. */\n    this._close = new Subject();\n    /** Emits once the MenuStack has become empty after popping off elements. */\n    this._empty = new Subject();\n    /** Emits whether any menu in the menu stack has focus. */\n    this._hasFocus = new Subject();\n    /** Observable which emits the MenuStackItem which has been requested to close. */\n    this.closed = this._close;\n    /** Observable which emits whether any menu in the menu stack has focus. */\n    this.hasFocus = this._hasFocus.pipe(startWith(false), debounceTime(0), distinctUntilChanged());\n    /**\r\n     * Observable which emits when the MenuStack is empty after popping off the last element. It\r\n     * emits a FocusNext event which specifies the action the closer has requested the listener\r\n     * perform.\r\n     */\n    this.emptied = this._empty;\n    /**\r\n     * Whether the inline menu associated with this menu stack is vertical or horizontal.\r\n     * `null` indicates there is no inline menu associated with this menu stack.\r\n     */\n    this._inlineMenuOrientation = null;\n  }\n  /** Creates a menu stack that originates from an inline menu. */\n  static inline(orientation) {\n    const stack = new MenuStack();\n    stack._inlineMenuOrientation = orientation;\n    return stack;\n  }\n  /**\r\n   * Adds an item to the menu stack.\r\n   * @param menu the MenuStackItem to put on the stack.\r\n   */\n  push(menu) {\n    this._elements.push(menu);\n  }\n  /**\r\n   * Pop items off of the stack up to and including `lastItem` and emit each on the close\r\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\r\n   * @param lastItem the last item to pop off the stack.\r\n   * @param options Options that configure behavior on close.\r\n   */\n  close(lastItem, options) {\n    const {\n      focusNextOnEmpty,\n      focusParentTrigger\n    } = {\n      ...options\n    };\n    if (this._elements.indexOf(lastItem) >= 0) {\n      let poppedElement;\n      do {\n        poppedElement = this._elements.pop();\n        this._close.next({\n          item: poppedElement,\n          focusParentTrigger\n        });\n      } while (poppedElement !== lastItem);\n      if (this.isEmpty()) {\n        this._empty.next(focusNextOnEmpty);\n      }\n    }\n  }\n  /**\r\n   * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\r\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\r\n   * @param lastItem the element which should be left on the stack\r\n   * @return whether or not an item was removed from the stack\r\n   */\n  closeSubMenuOf(lastItem) {\n    let removed = false;\n    if (this._elements.indexOf(lastItem) >= 0) {\n      removed = this.peek() !== lastItem;\n      while (this.peek() !== lastItem) {\n        this._close.next({\n          item: this._elements.pop()\n        });\n      }\n    }\n    return removed;\n  }\n  /**\r\n   * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\r\n   * @param options Options that configure behavior on close.\r\n   */\n  closeAll(options) {\n    const {\n      focusNextOnEmpty,\n      focusParentTrigger\n    } = {\n      ...options\n    };\n    if (!this.isEmpty()) {\n      while (!this.isEmpty()) {\n        const menuStackItem = this._elements.pop();\n        if (menuStackItem) {\n          this._close.next({\n            item: menuStackItem,\n            focusParentTrigger\n          });\n        }\n      }\n      this._empty.next(focusNextOnEmpty);\n    }\n  }\n  /** Return true if this stack is empty. */\n  isEmpty() {\n    return !this._elements.length;\n  }\n  /** Return the length of the stack. */\n  length() {\n    return this._elements.length;\n  }\n  /** Get the top most element on the stack. */\n  peek() {\n    return this._elements[this._elements.length - 1];\n  }\n  /** Whether the menu stack is associated with an inline menu. */\n  hasInlineMenu() {\n    return this._inlineMenuOrientation != null;\n  }\n  /** The orientation of the associated inline menu. */\n  inlineMenuOrientation() {\n    return this._inlineMenuOrientation;\n  }\n  /** Sets whether the menu stack contains the focused element. */\n  setHasFocus(hasFocus) {\n    this._hasFocus.next(hasFocus);\n  }\n}\nMenuStack.ɵfac = function MenuStack_Factory(t) {\n  return new (t || MenuStack)();\n};\nMenuStack.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: MenuStack,\n  factory: MenuStack.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MenuStack, [{\n    type: Injectable\n  }], null, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** Injection token used for an implementation of MenuStack. */\nconst MENU_TRIGGER = new InjectionToken('cdk-menu-trigger');\n/**\r\n * Abstract directive that implements shared logic common to all menu triggers.\r\n * This class can be extended to create custom menu trigger types.\r\n */\nclass CdkMenuTriggerBase {\n  constructor() {\n    /** The DI injector for this component. */\n    this.injector = inject(Injector);\n    /** The view container ref for this component */\n    this.viewContainerRef = inject(ViewContainerRef);\n    /** The menu stack in which this menu resides. */\n    this.menuStack = inject(MENU_STACK);\n    /** Emits when the attached menu is requested to open */\n    this.opened = new EventEmitter();\n    /** Emits when the attached menu is requested to close */\n    this.closed = new EventEmitter();\n    /** A reference to the overlay which manages the triggered menu */\n    this.overlayRef = null;\n    /** Emits when this trigger is destroyed. */\n    this.destroyed = new Subject();\n    /** Emits when the outside pointer events listener on the overlay should be stopped. */\n    this.stopOutsideClicksListener = merge(this.closed, this.destroyed);\n  }\n  ngOnDestroy() {\n    this._destroyOverlay();\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n  /** Whether the attached menu is open. */\n  isOpen() {\n    return !!this.overlayRef?.hasAttached();\n  }\n  /** Registers a child menu as having been opened by this trigger. */\n  registerChildMenu(child) {\n    this.childMenu = child;\n  }\n  /**\r\n   * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\r\n   * content to change dynamically and be reflected in the application.\r\n   */\n  getMenuContentPortal() {\n    const hasMenuContentChanged = this.menuTemplateRef !== this._menuPortal?.templateRef;\n    if (this.menuTemplateRef && (!this._menuPortal || hasMenuContentChanged)) {\n      this._menuPortal = new TemplatePortal(this.menuTemplateRef, this.viewContainerRef, this.menuData, this._getChildMenuInjector());\n    }\n    return this._menuPortal;\n  }\n  /**\r\n   * Whether the given element is inside the scope of this trigger's menu stack.\r\n   * @param element The element to check.\r\n   * @return Whether the element is inside the scope of this trigger's menu stack.\r\n   */\n  isElementInsideMenuStack(element) {\n    for (let el = element; el; el = el?.parentElement ?? null) {\n      if (el.getAttribute('data-cdk-menu-stack-id') === this.menuStack.id) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /** Destroy and unset the overlay reference it if exists */\n  _destroyOverlay() {\n    if (this.overlayRef) {\n      this.overlayRef.dispose();\n      this.overlayRef = null;\n    }\n  }\n  /** Gets the injector to use when creating a child menu. */\n  _getChildMenuInjector() {\n    this._childMenuInjector = this._childMenuInjector || Injector.create({\n      providers: [{\n        provide: MENU_TRIGGER,\n        useValue: this\n      }, {\n        provide: MENU_STACK,\n        useValue: this.menuStack\n      }],\n      parent: this.injector\n    });\n    return this._childMenuInjector;\n  }\n}\nCdkMenuTriggerBase.ɵfac = function CdkMenuTriggerBase_Factory(t) {\n  return new (t || CdkMenuTriggerBase)();\n};\nCdkMenuTriggerBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuTriggerBase,\n  hostVars: 2,\n  hostBindings: function CdkMenuTriggerBase_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-controls\", ctx.childMenu == null ? null : ctx.childMenu.id)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n    }\n  }\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuTriggerBase, [{\n    type: Directive,\n    args: [{\n      host: {\n        '[attr.aria-controls]': 'childMenu?.id',\n        '[attr.data-cdk-menu-stack-id]': 'menuStack.id'\n      }\n    }]\n  }], null, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * Throws an exception when an instance of the PointerFocusTracker is not provided.\r\n * @docs-private\r\n */\nfunction throwMissingPointerFocusTracker() {\n  throw Error('expected an instance of PointerFocusTracker to be provided');\n}\n/**\r\n * Throws an exception when a reference to the parent menu is not provided.\r\n * @docs-private\r\n */\nfunction throwMissingMenuReference() {\n  throw Error('expected a reference to the parent menu');\n}\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** Injection token used for an implementation of MenuAim. */\nconst MENU_AIM = new InjectionToken('cdk-menu-aim');\n/** Capture every nth mouse move event. */\nconst MOUSE_MOVE_SAMPLE_FREQUENCY = 3;\n/** The number of mouse move events to track. */\nconst NUM_POINTS = 5;\n/**\r\n * How long to wait before closing a sibling menu if a user stops short of the submenu they were\r\n * predicted to go into.\r\n */\nconst CLOSE_DELAY = 300;\n/** Calculate the slope between point a and b. */\nfunction getSlope(a, b) {\n  return (b.y - a.y) / (b.x - a.x);\n}\n/** Calculate the y intercept for the given point and slope. */\nfunction getYIntercept(point, slope) {\n  return point.y - slope * point.x;\n}\n/**\r\n * Whether the given mouse trajectory line defined by the slope and y intercept falls within the\r\n * submenu as defined by `submenuPoints`\r\n * @param submenuPoints the submenu DOMRect points.\r\n * @param m the slope of the trajectory line.\r\n * @param b the y intercept of the trajectory line.\r\n * @return true if any point on the line falls within the submenu.\r\n */\nfunction isWithinSubmenu(submenuPoints, m, b) {\n  const {\n    left,\n    right,\n    top,\n    bottom\n  } = submenuPoints;\n  // Check for intersection with each edge of the submenu (left, right, top, bottom)\n  // by fixing one coordinate to that edge's coordinate (either x or y) and checking if the\n  // other coordinate is within bounds.\n  return m * left + b >= top && m * left + b <= bottom || m * right + b >= top && m * right + b <= bottom || (top - b) / m >= left && (top - b) / m <= right || (bottom - b) / m >= left && (bottom - b) / m <= right;\n}\n/**\r\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\r\n * trajectory of the user's mouse movement in the current menu to determine if the\r\n * mouse is moving towards an open submenu.\r\n *\r\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\r\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\r\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\r\n * to submenu.\r\n */\nclass TargetMenuAim {\n  constructor() {\n    /** The Angular zone. */\n    this._ngZone = inject(NgZone);\n    /** The last NUM_POINTS mouse move events. */\n    this._points = [];\n    /** Emits when this service is destroyed. */\n    this._destroyed = new Subject();\n  }\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /**\r\n   * Set the Menu and its PointerFocusTracker.\r\n   * @param menu The menu that this menu aim service controls.\r\n   * @param pointerTracker The `PointerFocusTracker` for the given menu.\r\n   */\n  initialize(menu, pointerTracker) {\n    this._menu = menu;\n    this._pointerTracker = pointerTracker;\n    this._subscribeToMouseMoves();\n  }\n  /**\r\n   * Calls the `doToggle` callback when it is deemed that the user is not moving towards\r\n   * the submenu.\r\n   * @param doToggle the function called when the user is not moving towards the submenu.\r\n   */\n  toggle(doToggle) {\n    // If the menu is horizontal the sub-menus open below and there is no risk of premature\n    // closing of any sub-menus therefore we automatically resolve the callback.\n    if (this._menu.orientation === 'horizontal') {\n      doToggle();\n    }\n    this._checkConfigured();\n    const siblingItemIsWaiting = !!this._timeoutId;\n    const hasPoints = this._points.length > 1;\n    if (hasPoints && !siblingItemIsWaiting) {\n      if (this._isMovingToSubmenu()) {\n        this._startTimeout(doToggle);\n      } else {\n        doToggle();\n      }\n    } else if (!siblingItemIsWaiting) {\n      doToggle();\n    }\n  }\n  /**\r\n   * Start the delayed toggle handler if one isn't running already.\r\n   *\r\n   * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\r\n   * users mouse is on an item in the current menu.\r\n   *\r\n   * @param doToggle the function called when the user is not moving towards the submenu.\r\n   */\n  _startTimeout(doToggle) {\n    // If the users mouse is moving towards a submenu we don't want to immediately resolve.\n    // Wait for some period of time before determining if the previous menu should close in\n    // cases where the user may have moved towards the submenu but stopped on a sibling menu\n    // item intentionally.\n    const timeoutId = setTimeout(() => {\n      // Resolve if the user is currently moused over some element in the root menu\n      if (this._pointerTracker.activeElement && timeoutId === this._timeoutId) {\n        doToggle();\n      }\n      this._timeoutId = null;\n    }, CLOSE_DELAY);\n    this._timeoutId = timeoutId;\n  }\n  /** Whether the user is heading towards the open submenu. */\n  _isMovingToSubmenu() {\n    const submenuPoints = this._getSubmenuBounds();\n    if (!submenuPoints) {\n      return false;\n    }\n    let numMoving = 0;\n    const currPoint = this._points[this._points.length - 1];\n    // start from the second last point and calculate the slope between each point and the last\n    // point.\n    for (let i = this._points.length - 2; i >= 0; i--) {\n      const previous = this._points[i];\n      const slope = getSlope(currPoint, previous);\n      if (isWithinSubmenu(submenuPoints, slope, getYIntercept(currPoint, slope))) {\n        numMoving++;\n      }\n    }\n    return numMoving >= Math.floor(NUM_POINTS / 2);\n  }\n  /** Get the bounding DOMRect for the open submenu. */\n  _getSubmenuBounds() {\n    return this._pointerTracker?.previousElement?.getMenu()?.nativeElement.getBoundingClientRect();\n  }\n  /**\r\n   * Check if a reference to the PointerFocusTracker and menu element is provided.\r\n   * @throws an error if neither reference is provided.\r\n   */\n  _checkConfigured() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._pointerTracker) {\n        throwMissingPointerFocusTracker();\n      }\n      if (!this._menu) {\n        throwMissingMenuReference();\n      }\n    }\n  }\n  /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\n  _subscribeToMouseMoves() {\n    this._ngZone.runOutsideAngular(() => {\n      fromEvent(this._menu.nativeElement, 'mousemove').pipe(filter((_, index) => index % MOUSE_MOVE_SAMPLE_FREQUENCY === 0), takeUntil(this._destroyed)).subscribe(event => {\n        this._points.push({\n          x: event.clientX,\n          y: event.clientY\n        });\n        if (this._points.length > NUM_POINTS) {\n          this._points.shift();\n        }\n      });\n    });\n  }\n}\nTargetMenuAim.ɵfac = function TargetMenuAim_Factory(t) {\n  return new (t || TargetMenuAim)();\n};\nTargetMenuAim.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TargetMenuAim,\n  factory: TargetMenuAim.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TargetMenuAim, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\r\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\r\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\r\n */\nclass CdkTargetMenuAim {}\nCdkTargetMenuAim.ɵfac = function CdkTargetMenuAim_Factory(t) {\n  return new (t || CdkTargetMenuAim)();\n};\nCdkTargetMenuAim.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkTargetMenuAim,\n  selectors: [[\"\", \"cdkTargetMenuAim\", \"\"]],\n  exportAs: [\"cdkTargetMenuAim\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: MENU_AIM,\n    useClass: TargetMenuAim\n  }])]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTargetMenuAim, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTargetMenuAim]',\n      exportAs: 'cdkTargetMenuAim',\n      standalone: true,\n      providers: [{\n        provide: MENU_AIM,\n        useClass: TargetMenuAim\n      }]\n    }]\n  }], null, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * A directive that turns its host element into a trigger for a popup menu.\r\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\r\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\r\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\r\n * state.\r\n */\nclass CdkMenuTrigger extends CdkMenuTriggerBase {\n  constructor() {\n    super();\n    this._elementRef = inject(ElementRef);\n    this._overlay = inject(Overlay);\n    this._ngZone = inject(NgZone);\n    this._directionality = inject(Directionality, {\n      optional: true\n    });\n    this._inputModalityDetector = inject(InputModalityDetector);\n    /** The parent menu this trigger belongs to. */\n    this._parentMenu = inject(CDK_MENU, {\n      optional: true\n    });\n    /** The menu aim service used by this menu. */\n    this._menuAim = inject(MENU_AIM, {\n      optional: true\n    });\n    this._setRole();\n    this._registerCloseHandler();\n    this._subscribeToMenuStackClosed();\n    this._subscribeToMouseEnter();\n    this._subscribeToMenuStackHasFocus();\n    this._setType();\n  }\n  /** Toggle the attached menu. */\n  toggle() {\n    this.isOpen() ? this.close() : this.open();\n  }\n  /** Open the attached menu. */\n  open() {\n    if (!this.isOpen() && this.menuTemplateRef != null) {\n      this.opened.next();\n      this.overlayRef = this.overlayRef || this._overlay.create(this._getOverlayConfig());\n      this.overlayRef.attach(this.getMenuContentPortal());\n      this._subscribeToOutsideClicks();\n    }\n  }\n  /** Close the opened menu. */\n  close() {\n    if (this.isOpen()) {\n      this.closed.next();\n      this.overlayRef.detach();\n    }\n    this._closeSiblingTriggers();\n  }\n  /**\r\n   * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\r\n   */\n  getMenu() {\n    return this.childMenu;\n  }\n  /**\r\n   * Handles keyboard events for the menu item.\r\n   * @param event The keyboard event to handle\r\n   */\n  _toggleOnKeydown(event) {\n    const isParentVertical = this._parentMenu?.orientation === 'vertical';\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        if (!hasModifierKey(event)) {\n          this.toggle();\n          this.childMenu?.focusFirstItem('keyboard');\n        }\n        break;\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value !== 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n        break;\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value === 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n        break;\n      case DOWN_ARROW:\n      case UP_ARROW:\n        if (!hasModifierKey(event)) {\n          if (!isParentVertical) {\n            event.preventDefault();\n            this.open();\n            event.keyCode === DOWN_ARROW ? this.childMenu?.focusFirstItem('keyboard') : this.childMenu?.focusLastItem('keyboard');\n          }\n        }\n        break;\n    }\n  }\n  /** Handles clicks on the menu trigger. */\n  _handleClick() {\n    // Don't handle clicks originating from the keyboard since we\n    // already do the same on `keydown` events for enter and space.\n    if (this._inputModalityDetector.mostRecentModality !== 'keyboard') {\n      this.toggle();\n    }\n  }\n  /**\r\n   * Sets whether the trigger's menu stack has focus.\r\n   * @param hasFocus Whether the menu stack has focus.\r\n   */\n  _setHasFocus(hasFocus) {\n    if (!this._parentMenu) {\n      this.menuStack.setHasFocus(hasFocus);\n    }\n  }\n  /**\r\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\r\n   * into.\r\n   */\n  _subscribeToMouseEnter() {\n    this._ngZone.runOutsideAngular(() => {\n      fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => !this.menuStack.isEmpty() && !this.isOpen()), takeUntil(this.destroyed)).subscribe(() => {\n        // Closes any sibling menu items and opens the menu associated with this trigger.\n        const toggleMenus = () => this._ngZone.run(() => {\n          this._closeSiblingTriggers();\n          this.open();\n        });\n        if (this._menuAim) {\n          this._menuAim.toggle(toggleMenus);\n        } else {\n          toggleMenus();\n        }\n      });\n    });\n  }\n  /** Close out any sibling menu trigger menus. */\n  _closeSiblingTriggers() {\n    if (this._parentMenu) {\n      // If nothing was removed from the stack and the last element is not the parent item\n      // that means that the parent menu is a menu bar since we don't put the menu bar on the\n      // stack\n      const isParentMenuBar = !this.menuStack.closeSubMenuOf(this._parentMenu) && this.menuStack.peek() !== this._parentMenu;\n      if (isParentMenuBar) {\n        this.menuStack.closeAll();\n      }\n    } else {\n      this.menuStack.closeAll();\n    }\n  }\n  /** Get the configuration object used to create the overlay. */\n  _getOverlayConfig() {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(),\n      scrollStrategy: this._overlay.scrollStrategies.reposition(),\n      direction: this._directionality || undefined\n    });\n  }\n  /** Build the position strategy for the overlay which specifies where to place the menu. */\n  _getOverlayPositionStrategy() {\n    return this._overlay.position().flexibleConnectedTo(this._elementRef).withLockedPosition().withGrowAfterOpen().withPositions(this._getOverlayPositions());\n  }\n  /** Get the preferred positions for the opened menu relative to the menu item. */\n  _getOverlayPositions() {\n    return this.menuPosition ?? (!this._parentMenu || this._parentMenu.orientation === 'horizontal' ? STANDARD_DROPDOWN_BELOW_POSITIONS : STANDARD_DROPDOWN_ADJACENT_POSITIONS);\n  }\n  /**\r\n   * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\r\n   * this triggers when requested.\r\n   */\n  _registerCloseHandler() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n        item\n      }) => {\n        if (item === this.childMenu) {\n          this.close();\n        }\n      });\n    }\n  }\n  /**\r\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\r\n   * click occurs outside the menus.\r\n   */\n  _subscribeToOutsideClicks() {\n    if (this.overlayRef) {\n      this.overlayRef.outsidePointerEvents().pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n        const target = _getEventTarget(event);\n        const element = this._elementRef.nativeElement;\n        if (target !== element && !element.contains(target)) {\n          if (!this.isElementInsideMenuStack(target)) {\n            this.menuStack.closeAll();\n          } else {\n            this._closeSiblingTriggers();\n          }\n        }\n      });\n    }\n  }\n  /** Subscribe to the MenuStack hasFocus events. */\n  _subscribeToMenuStackHasFocus() {\n    if (!this._parentMenu) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        if (!hasFocus) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n  /** Subscribe to the MenuStack closed events. */\n  _subscribeToMenuStackClosed() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.subscribe(({\n        focusParentTrigger\n      }) => {\n        if (focusParentTrigger && !this.menuStack.length()) {\n          this._elementRef.nativeElement.focus();\n        }\n      });\n    }\n  }\n  /** Sets the role attribute for this trigger if needed. */\n  _setRole() {\n    // If this trigger is part of another menu, the cdkMenuItem directive will handle setting the\n    // role, otherwise this is a standalone trigger, and we should ensure it has role=\"button\".\n    if (!this._parentMenu) {\n      this._elementRef.nativeElement.setAttribute('role', 'button');\n    }\n  }\n  /** Sets thte `type` attribute of the trigger. */\n  _setType() {\n    const element = this._elementRef.nativeElement;\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevents form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n}\nCdkMenuTrigger.ɵfac = function CdkMenuTrigger_Factory(t) {\n  return new (t || CdkMenuTrigger)();\n};\nCdkMenuTrigger.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuTrigger,\n  selectors: [[\"\", \"cdkMenuTriggerFor\", \"\"]],\n  hostAttrs: [1, \"cdk-menu-trigger\"],\n  hostVars: 2,\n  hostBindings: function CdkMenuTrigger_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"focusin\", function CdkMenuTrigger_focusin_HostBindingHandler() {\n        return ctx._setHasFocus(true);\n      })(\"focusout\", function CdkMenuTrigger_focusout_HostBindingHandler() {\n        return ctx._setHasFocus(false);\n      })(\"keydown\", function CdkMenuTrigger_keydown_HostBindingHandler($event) {\n        return ctx._toggleOnKeydown($event);\n      })(\"click\", function CdkMenuTrigger_click_HostBindingHandler() {\n        return ctx._handleClick();\n      });\n    }\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-haspopup\", ctx.menuTemplateRef ? \"menu\" : null)(\"aria-expanded\", ctx.menuTemplateRef == null ? null : ctx.isOpen());\n    }\n  },\n  inputs: {\n    menuTemplateRef: [\"cdkMenuTriggerFor\", \"menuTemplateRef\"],\n    menuPosition: [\"cdkMenuPosition\", \"menuPosition\"],\n    menuData: [\"cdkMenuTriggerData\", \"menuData\"]\n  },\n  outputs: {\n    opened: \"cdkMenuOpened\",\n    closed: \"cdkMenuClosed\"\n  },\n  exportAs: [\"cdkMenuTriggerFor\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: MENU_TRIGGER,\n    useExisting: CdkMenuTrigger\n  }, PARENT_OR_NEW_MENU_STACK_PROVIDER]), i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuTriggerFor]',\n      exportAs: 'cdkMenuTriggerFor',\n      standalone: true,\n      host: {\n        'class': 'cdk-menu-trigger',\n        '[attr.aria-haspopup]': 'menuTemplateRef ? \"menu\" : null',\n        '[attr.aria-expanded]': 'menuTemplateRef == null ? null : isOpen()',\n        '(focusin)': '_setHasFocus(true)',\n        '(focusout)': '_setHasFocus(false)',\n        '(keydown)': '_toggleOnKeydown($event)',\n        '(click)': '_handleClick()'\n      },\n      inputs: ['menuTemplateRef: cdkMenuTriggerFor', 'menuPosition: cdkMenuPosition', 'menuData: cdkMenuTriggerData'],\n      outputs: ['opened: cdkMenuOpened', 'closed: cdkMenuClosed'],\n      providers: [{\n        provide: MENU_TRIGGER,\n        useExisting: CdkMenuTrigger\n      }, PARENT_OR_NEW_MENU_STACK_PROVIDER]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * Directive which provides the ability for an element to be focused and navigated to using the\r\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\r\n * behavior when clicked.\r\n */\nclass CdkMenuItem {\n  /**  Whether the CdkMenuItem is disabled - defaults to false */\n  get disabled() {\n    return this._disabled;\n  }\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  /** Whether the menu item opens a menu. */\n  get hasMenu() {\n    return this._menuTrigger?.menuTemplateRef != null;\n  }\n  constructor() {\n    this._dir = inject(Directionality, {\n      optional: true\n    });\n    this._inputModalityDetector = inject(InputModalityDetector);\n    this._elementRef = inject(ElementRef);\n    this._ngZone = inject(NgZone);\n    /** The menu aim service used by this menu. */\n    this._menuAim = inject(MENU_AIM, {\n      optional: true\n    });\n    /** The stack of menus this menu belongs to. */\n    this._menuStack = inject(MENU_STACK);\n    /** The parent menu in which this menuitem resides. */\n    this._parentMenu = inject(CDK_MENU, {\n      optional: true\n    });\n    /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\n    this._menuTrigger = inject(CdkMenuTrigger, {\n      optional: true,\n      self: true\n    });\n    this._disabled = false;\n    /**\r\n     * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\r\n     * event.\r\n     */\n    this.triggered = new EventEmitter();\n    /**\r\n     * The tabindex for this menu item managed internally and used for implementing roving a\r\n     * tab index.\r\n     */\n    this._tabindex = -1;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n    this.closeOnSpacebarTrigger = true;\n    /** Emits when the menu item is destroyed. */\n    this.destroyed = new Subject();\n    this._setupMouseEnter();\n    this._setType();\n    if (this._isStandaloneItem()) {\n      this._tabindex = 0;\n    }\n  }\n  ngOnDestroy() {\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n  /** Place focus on the element. */\n  focus() {\n    this._elementRef.nativeElement.focus();\n  }\n  /**\r\n   * If the menu item is not disabled and the element does not have a menu trigger attached, emit\r\n   * on the cdkMenuItemTriggered emitter and close all open menus.\r\n   * @param options Options the configure how the item is triggered\r\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\r\n   */\n  trigger(options) {\n    const {\n      keepOpen\n    } = {\n      ...options\n    };\n    if (!this.disabled && !this.hasMenu) {\n      this.triggered.next();\n      if (!keepOpen) {\n        this._menuStack.closeAll({\n          focusParentTrigger: true\n        });\n      }\n    }\n  }\n  /** Return true if this MenuItem has an attached menu and it is open. */\n  isMenuOpen() {\n    return !!this._menuTrigger?.isOpen();\n  }\n  /**\r\n   * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\r\n   * @return the menu if it is open, otherwise undefined.\r\n   */\n  getMenu() {\n    return this._menuTrigger?.getMenu();\n  }\n  /** Get the CdkMenuTrigger associated with this element. */\n  getMenuTrigger() {\n    return this._menuTrigger;\n  }\n  /** Get the label for this element which is required by the FocusableOption interface. */\n  getLabel() {\n    return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n  }\n  /** Reset the tabindex to -1. */\n  _resetTabIndex() {\n    if (!this._isStandaloneItem()) {\n      this._tabindex = -1;\n    }\n  }\n  /**\r\n   * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\r\n   * is not in a menu bar.\r\n   */\n  _setTabIndex(event) {\n    if (this.disabled) {\n      return;\n    }\n    // don't set the tabindex if there are no open sibling or parent menus\n    if (!event || !this._menuStack.isEmpty()) {\n      this._tabindex = 0;\n    }\n  }\n  /**\r\n   * Handles keyboard events for the menu item, specifically either triggering the user defined\r\n   * callback or opening/closing the current menu based on whether the left or right arrow key was\r\n   * pressed.\r\n   * @param event the keyboard event to handle\r\n   */\n  _onKeydown(event) {\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        if (!hasModifierKey(event)) {\n          this.trigger({\n            keepOpen: event.keyCode === SPACE && !this.closeOnSpacebarTrigger\n          });\n        }\n        break;\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._forwardArrowPressed(event);\n            } else {\n              this._backArrowPressed(event);\n            }\n          }\n        }\n        break;\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._backArrowPressed(event);\n            } else {\n              this._forwardArrowPressed(event);\n            }\n          }\n        }\n        break;\n    }\n  }\n  /** Handles clicks on the menu item. */\n  _handleClick() {\n    // Don't handle clicks originating from the keyboard since we\n    // already do the same on `keydown` events for enter and space.\n    if (this._inputModalityDetector.mostRecentModality !== 'keyboard') {\n      this.trigger();\n    }\n  }\n  /** Whether this menu item is standalone or within a menu or menu bar. */\n  _isStandaloneItem() {\n    return !this._parentMenu;\n  }\n  /**\r\n   * Handles the user pressing the back arrow key.\r\n   * @param event The keyboard event.\r\n   */\n  _backArrowPressed(event) {\n    const parentMenu = this._parentMenu;\n    if (this._menuStack.hasInlineMenu() || this._menuStack.length() > 1) {\n      event.preventDefault();\n      this._menuStack.close(parentMenu, {\n        focusNextOnEmpty: this._menuStack.inlineMenuOrientation() === 'horizontal' ? 1 /* FocusNext.previousItem */ : 2 /* FocusNext.currentItem */,\n        focusParentTrigger: true\n      });\n    }\n  }\n  /**\r\n   * Handles the user pressing the forward arrow key.\r\n   * @param event The keyboard event.\r\n   */\n  _forwardArrowPressed(event) {\n    if (!this.hasMenu && this._menuStack.inlineMenuOrientation() === 'horizontal') {\n      event.preventDefault();\n      this._menuStack.closeAll({\n        focusNextOnEmpty: 0 /* FocusNext.nextItem */,\n        focusParentTrigger: true\n      });\n    }\n  }\n  /**\r\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\r\n   * into.\r\n   */\n  _setupMouseEnter() {\n    if (!this._isStandaloneItem()) {\n      const closeOpenSiblings = () => this._ngZone.run(() => this._menuStack.closeSubMenuOf(this._parentMenu));\n      this._ngZone.runOutsideAngular(() => fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => !this._menuStack.isEmpty() && !this.hasMenu), takeUntil(this.destroyed)).subscribe(() => {\n        if (this._menuAim) {\n          this._menuAim.toggle(closeOpenSiblings);\n        } else {\n          closeOpenSiblings();\n        }\n      }));\n    }\n  }\n  /**\r\n   * Return true if the enclosing parent menu is configured in a horizontal orientation, false\r\n   * otherwise or if no parent.\r\n   */\n  _isParentVertical() {\n    return this._parentMenu?.orientation === 'vertical';\n  }\n  /** Sets the `type` attribute of the menu item. */\n  _setType() {\n    const element = this._elementRef.nativeElement;\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevent form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n}\nCdkMenuItem.ɵfac = function CdkMenuItem_Factory(t) {\n  return new (t || CdkMenuItem)();\n};\nCdkMenuItem.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItem,\n  selectors: [[\"\", \"cdkMenuItem\", \"\"]],\n  hostAttrs: [\"role\", \"menuitem\", 1, \"cdk-menu-item\"],\n  hostVars: 2,\n  hostBindings: function CdkMenuItem_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"blur\", function CdkMenuItem_blur_HostBindingHandler() {\n        return ctx._resetTabIndex();\n      })(\"focus\", function CdkMenuItem_focus_HostBindingHandler() {\n        return ctx._setTabIndex();\n      })(\"click\", function CdkMenuItem_click_HostBindingHandler() {\n        return ctx._handleClick();\n      })(\"keydown\", function CdkMenuItem_keydown_HostBindingHandler($event) {\n        return ctx._onKeydown($event);\n      });\n    }\n    if (rf & 2) {\n      i0.ɵɵhostProperty(\"tabindex\", ctx._tabindex);\n      i0.ɵɵattribute(\"aria-disabled\", ctx.disabled || null);\n    }\n  },\n  inputs: {\n    disabled: [\"cdkMenuItemDisabled\", \"disabled\"],\n    typeaheadLabel: [\"cdkMenuitemTypeaheadLabel\", \"typeaheadLabel\"]\n  },\n  outputs: {\n    triggered: \"cdkMenuItemTriggered\"\n  },\n  exportAs: [\"cdkMenuItem\"],\n  standalone: true\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItem, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItem]',\n      exportAs: 'cdkMenuItem',\n      standalone: true,\n      host: {\n        'role': 'menuitem',\n        'class': 'cdk-menu-item',\n        '[tabindex]': '_tabindex',\n        '[attr.aria-disabled]': 'disabled || null',\n        '(blur)': '_resetTabIndex()',\n        '(focus)': '_setTabIndex()',\n        '(click)': '_handleClick()',\n        '(keydown)': '_onKeydown($event)'\n      }\n    }]\n  }], function () {\n    return [];\n  }, {\n    disabled: [{\n      type: Input,\n      args: ['cdkMenuItemDisabled']\n    }],\n    typeaheadLabel: [{\n      type: Input,\n      args: ['cdkMenuitemTypeaheadLabel']\n    }],\n    triggered: [{\n      type: Output,\n      args: ['cdkMenuItemTriggered']\n    }]\n  });\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\r\n * observables which emit when the users mouse enters and leaves a tracked element.\r\n */\nclass PointerFocusTracker {\n  constructor( /** The list of items being tracked. */\n  _items) {\n    this._items = _items;\n    /** Emits when an element is moused into. */\n    this.entered = this._getItemPointerEntries();\n    /** Emits when an element is moused out. */\n    this.exited = this._getItemPointerExits();\n    /** Emits when this is destroyed. */\n    this._destroyed = new Subject();\n    this.entered.subscribe(element => this.activeElement = element);\n    this.exited.subscribe(() => {\n      this.previousElement = this.activeElement;\n      this.activeElement = undefined;\n    });\n  }\n  /** Stop the managers listeners. */\n  destroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /**\r\n   * Gets a stream of pointer (mouse) entries into the given items.\r\n   * This should typically run outside the Angular zone.\r\n   */\n  _getItemPointerEntries() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseenter').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n  /**\r\n   * Gets a stream of pointer (mouse) exits out of the given items.\r\n   * This should typically run outside the Angular zone.\r\n   */\n  _getItemPointerExits() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseout').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n}\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** Counter used to create unique IDs for menus. */\nlet nextId$1 = 0;\n/**\r\n * Abstract directive that implements shared logic common to all menus.\r\n * This class can be extended to create custom menu types.\r\n */\nclass CdkMenuBase extends CdkMenuGroup {\n  constructor() {\n    super(...arguments);\n    /** The menu's native DOM host element. */\n    this.nativeElement = inject(ElementRef).nativeElement;\n    /** The Angular zone. */\n    this.ngZone = inject(NgZone);\n    /** The stack of menus this menu belongs to. */\n    this.menuStack = inject(MENU_STACK);\n    /** The menu aim service used by this menu. */\n    this.menuAim = inject(MENU_AIM, {\n      optional: true,\n      self: true\n    });\n    /** The directionality (text direction) of the current page. */\n    this.dir = inject(Directionality, {\n      optional: true\n    });\n    /** The id of the menu's host element. */\n    this.id = `cdk-menu-${nextId$1++}`;\n    /** The direction items in the menu flow. */\n    this.orientation = 'vertical';\n    /**\r\n     * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\r\n     * user triggers with a trigger element).\r\n     */\n    this.isInline = false;\n    /** Emits when the MenuBar is destroyed. */\n    this.destroyed = new Subject();\n    /** Whether this menu's menu stack has focus. */\n    this._menuStackHasFocus = false;\n  }\n  ngAfterContentInit() {\n    if (!this.isInline) {\n      this.menuStack.push(this);\n    }\n    this._setKeyManager();\n    this._subscribeToMenuStackHasFocus();\n    this._subscribeToMenuOpen();\n    this._subscribeToMenuStackClosed();\n    this._setUpPointerTracker();\n  }\n  ngOnDestroy() {\n    this.keyManager?.destroy();\n    this.destroyed.next();\n    this.destroyed.complete();\n    this.pointerTracker?.destroy();\n  }\n  /**\r\n   * Place focus on the first MenuItem in the menu and set the focus origin.\r\n   * @param focusOrigin The origin input mode of the focus event.\r\n   */\n  focusFirstItem(focusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setFirstItemActive();\n  }\n  /**\r\n   * Place focus on the last MenuItem in the menu and set the focus origin.\r\n   * @param focusOrigin The origin input mode of the focus event.\r\n   */\n  focusLastItem(focusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setLastItemActive();\n  }\n  /** Gets the tabindex for this menu. */\n  _getTabIndex() {\n    const tabindexIfInline = this._menuStackHasFocus ? -1 : 0;\n    return this.isInline ? tabindexIfInline : null;\n  }\n  /**\r\n   * Close the open menu if the current active item opened the requested MenuStackItem.\r\n   * @param menu The menu requested to be closed.\r\n   * @param options Options to configure the behavior on close.\r\n   *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\r\n   */\n  closeOpenMenu(menu, options) {\n    const {\n      focusParentTrigger\n    } = {\n      ...options\n    };\n    const keyManager = this.keyManager;\n    const trigger = this.triggerItem;\n    if (menu === trigger?.getMenuTrigger()?.getMenu()) {\n      trigger?.getMenuTrigger()?.close();\n      // If the user has moused over a sibling item we want to focus the element under mouse focus\n      // not the trigger which previously opened the now closed menu.\n      if (focusParentTrigger) {\n        if (trigger) {\n          keyManager.setActiveItem(trigger);\n        } else {\n          keyManager.setFirstItemActive();\n        }\n      }\n    }\n  }\n  /** Setup the FocusKeyManager with the correct orientation for the menu. */\n  _setKeyManager() {\n    this.keyManager = new FocusKeyManager(this.items).withWrap().withTypeAhead().withHomeAndEnd();\n    if (this.orientation === 'horizontal') {\n      this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');\n    } else {\n      this.keyManager.withVerticalOrientation();\n    }\n  }\n  /**\r\n   * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\r\n   * and stop tracking it when the menu is closed.\r\n   */\n  _subscribeToMenuOpen() {\n    const exitCondition = merge(this.items.changes, this.destroyed);\n    this.items.changes.pipe(startWith(this.items), mergeMap(list => list.filter(item => item.hasMenu).map(item => item.getMenuTrigger().opened.pipe(mapTo(item), takeUntil(exitCondition)))), mergeAll(), switchMap(item => {\n      this.triggerItem = item;\n      return item.getMenuTrigger().closed;\n    }), takeUntil(this.destroyed)).subscribe(() => this.triggerItem = undefined);\n  }\n  /** Subscribe to the MenuStack close events. */\n  _subscribeToMenuStackClosed() {\n    this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n      item,\n      focusParentTrigger\n    }) => this.closeOpenMenu(item, {\n      focusParentTrigger\n    }));\n  }\n  /** Subscribe to the MenuStack hasFocus events. */\n  _subscribeToMenuStackHasFocus() {\n    if (this.isInline) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        this._menuStackHasFocus = hasFocus;\n      });\n    }\n  }\n  /**\r\n   * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\r\n   * with the latest menu item under mouse focus.\r\n   */\n  _setUpPointerTracker() {\n    if (this.menuAim) {\n      this.ngZone.runOutsideAngular(() => {\n        this.pointerTracker = new PointerFocusTracker(this.items);\n      });\n      this.menuAim.initialize(this, this.pointerTracker);\n    }\n  }\n}\nCdkMenuBase.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuBase_BaseFactory;\n  return function CdkMenuBase_Factory(t) {\n    return (ɵCdkMenuBase_BaseFactory || (ɵCdkMenuBase_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBase)))(t || CdkMenuBase);\n  };\n}();\nCdkMenuBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuBase,\n  contentQueries: function CdkMenuBase_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, CdkMenuItem, 5);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n    }\n  },\n  hostAttrs: [\"role\", \"menu\"],\n  hostVars: 4,\n  hostBindings: function CdkMenuBase_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"focus\", function CdkMenuBase_focus_HostBindingHandler() {\n        return ctx.focusFirstItem();\n      })(\"focusin\", function CdkMenuBase_focusin_HostBindingHandler() {\n        return ctx.menuStack.setHasFocus(true);\n      })(\"focusout\", function CdkMenuBase_focusout_HostBindingHandler() {\n        return ctx.menuStack.setHasFocus(false);\n      });\n    }\n    if (rf & 2) {\n      i0.ɵɵhostProperty(\"tabindex\", ctx._getTabIndex())(\"id\", ctx.id);\n      i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n    }\n  },\n  inputs: {\n    id: \"id\"\n  },\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuBase, [{\n    type: Directive,\n    args: [{\n      host: {\n        'role': 'menu',\n        'class': '',\n        '[tabindex]': '_getTabIndex()',\n        '[id]': 'id',\n        '[attr.aria-orientation]': 'orientation',\n        '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\n        '(focus)': 'focusFirstItem()',\n        '(focusin)': 'menuStack.setHasFocus(true)',\n        '(focusout)': 'menuStack.setHasFocus(false)'\n      }\n    }]\n  }], null, {\n    id: [{\n      type: Input\n    }],\n    items: [{\n      type: ContentChildren,\n      args: [CdkMenuItem, {\n        descendants: true\n      }]\n    }]\n  });\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * Directive which configures the element as a Menu which should contain child elements marked as\r\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\r\n * contains accessible keyboard and mouse handling logic.\r\n *\r\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\r\n */\nclass CdkMenu extends CdkMenuBase {\n  constructor() {\n    super();\n    this._parentTrigger = inject(MENU_TRIGGER, {\n      optional: true\n    });\n    /** Event emitted when the menu is closed. */\n    this.closed = new EventEmitter();\n    /** The direction items in the menu flow. */\n    this.orientation = 'vertical';\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n    this.isInline = !this._parentTrigger;\n    this.destroyed.subscribe(this.closed);\n    this._parentTrigger?.registerChildMenu(this);\n  }\n  ngAfterContentInit() {\n    super.ngAfterContentInit();\n    this._subscribeToMenuStackEmptied();\n  }\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    this.closed.complete();\n  }\n  /**\r\n   * Handle keyboard events for the Menu.\r\n   * @param event The keyboard event to be handled.\r\n   */\n  _handleKeyEvent(event) {\n    const keyManager = this.keyManager;\n    switch (event.keyCode) {\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.onKeydown(event);\n        }\n        break;\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          this.menuStack.close(this, {\n            focusNextOnEmpty: 2 /* FocusNext.currentItem */,\n            focusParentTrigger: true\n          });\n        }\n        break;\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          this.menuStack.closeAll({\n            focusParentTrigger: true\n          });\n        }\n        break;\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n  /**\r\n   * Set focus the either the current, previous or next item based on the FocusNext event.\r\n   * @param focusNext The element to focus.\r\n   */\n  _toggleMenuFocus(focusNext) {\n    const keyManager = this.keyManager;\n    switch (focusNext) {\n      case 0 /* FocusNext.nextItem */:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        break;\n      case 1 /* FocusNext.previousItem */:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        break;\n      case 2 /* FocusNext.currentItem */:\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n        break;\n    }\n  }\n  /** Subscribe to the MenuStack emptied events. */\n  _subscribeToMenuStackEmptied() {\n    this.menuStack.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleMenuFocus(event));\n  }\n}\nCdkMenu.ɵfac = function CdkMenu_Factory(t) {\n  return new (t || CdkMenu)();\n};\nCdkMenu.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenu,\n  selectors: [[\"\", \"cdkMenu\", \"\"]],\n  hostAttrs: [\"role\", \"menu\", 1, \"cdk-menu\"],\n  hostVars: 2,\n  hostBindings: function CdkMenu_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"keydown\", function CdkMenu_keydown_HostBindingHandler($event) {\n        return ctx._handleKeyEvent($event);\n      });\n    }\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"cdk-menu-inline\", ctx.isInline);\n    }\n  },\n  outputs: {\n    closed: \"closed\"\n  },\n  exportAs: [\"cdkMenu\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuGroup,\n    useExisting: CdkMenu\n  }, {\n    provide: CDK_MENU,\n    useExisting: CdkMenu\n  }, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical')]), i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenu, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenu]',\n      exportAs: 'cdkMenu',\n      standalone: true,\n      host: {\n        'role': 'menu',\n        'class': 'cdk-menu',\n        '[class.cdk-menu-inline]': 'isInline',\n        '(keydown)': '_handleKeyEvent($event)'\n      },\n      providers: [{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenu\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenu\n      }, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical')]\n    }]\n  }], function () {\n    return [];\n  }, {\n    closed: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\r\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\r\n * this directive is applied to should contain components marked with CdkMenuItem.\r\n *\r\n */\nclass CdkMenuBar extends CdkMenuBase {\n  constructor() {\n    super(...arguments);\n    /** The direction items in the menu flow. */\n    this.orientation = 'horizontal';\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n    this.isInline = true;\n  }\n  ngAfterContentInit() {\n    super.ngAfterContentInit();\n    this._subscribeToMenuStackEmptied();\n  }\n  /**\r\n   * Handle keyboard events for the Menu.\r\n   * @param event The keyboard event to be handled.\r\n   */\n  _handleKeyEvent(event) {\n    const keyManager = this.keyManager;\n    switch (event.keyCode) {\n      case UP_ARROW:\n      case DOWN_ARROW:\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          const horizontalArrows = event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW;\n          // For a horizontal menu if the left/right keys were clicked, or a vertical menu if the\n          // up/down keys were clicked: if the current menu is open, close it then focus and open the\n          // next  menu.\n          if (horizontalArrows) {\n            event.preventDefault();\n            const prevIsOpen = keyManager.activeItem?.isMenuOpen();\n            keyManager.activeItem?.getMenuTrigger()?.close();\n            keyManager.setFocusOrigin('keyboard');\n            keyManager.onKeydown(event);\n            if (prevIsOpen) {\n              keyManager.activeItem?.getMenuTrigger()?.open();\n            }\n          }\n        }\n        break;\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n        break;\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n        break;\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n  /**\r\n   * Set focus to either the current, previous or next item based on the FocusNext event, then\r\n   * open the previous or next item.\r\n   * @param focusNext The element to focus.\r\n   */\n  _toggleOpenMenu(focusNext) {\n    const keyManager = this.keyManager;\n    switch (focusNext) {\n      case 0 /* FocusNext.nextItem */:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n      case 1 /* FocusNext.previousItem */:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n      case 2 /* FocusNext.currentItem */:\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n        break;\n    }\n  }\n  /** Subscribe to the MenuStack emptied events. */\n  _subscribeToMenuStackEmptied() {\n    this.menuStack?.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleOpenMenu(event));\n  }\n}\nCdkMenuBar.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuBar_BaseFactory;\n  return function CdkMenuBar_Factory(t) {\n    return (ɵCdkMenuBar_BaseFactory || (ɵCdkMenuBar_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBar)))(t || CdkMenuBar);\n  };\n}();\nCdkMenuBar.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuBar,\n  selectors: [[\"\", \"cdkMenuBar\", \"\"]],\n  hostAttrs: [\"role\", \"menubar\", 1, \"cdk-menu-bar\"],\n  hostBindings: function CdkMenuBar_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"keydown\", function CdkMenuBar_keydown_HostBindingHandler($event) {\n        return ctx._handleKeyEvent($event);\n      });\n    }\n  },\n  exportAs: [\"cdkMenuBar\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuGroup,\n    useExisting: CdkMenuBar\n  }, {\n    provide: CDK_MENU,\n    useExisting: CdkMenuBar\n  }, {\n    provide: MENU_STACK,\n    useFactory: () => MenuStack.inline('horizontal')\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuBar, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuBar]',\n      exportAs: 'cdkMenuBar',\n      standalone: true,\n      host: {\n        'role': 'menubar',\n        'class': 'cdk-menu-bar',\n        '(keydown)': '_handleKeyEvent($event)'\n      },\n      providers: [{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenuBar\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenuBar\n      }, {\n        provide: MENU_STACK,\n        useFactory: () => MenuStack.inline('horizontal')\n      }]\n    }]\n  }], null, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** Base class providing checked state for selectable MenuItems. */\nclass CdkMenuItemSelectable extends CdkMenuItem {\n  constructor() {\n    super(...arguments);\n    this._checked = false;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n    this.closeOnSpacebarTrigger = false;\n  }\n  /** Whether the element is checked */\n  get checked() {\n    return this._checked;\n  }\n  set checked(value) {\n    this._checked = coerceBooleanProperty(value);\n  }\n}\nCdkMenuItemSelectable.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuItemSelectable_BaseFactory;\n  return function CdkMenuItemSelectable_Factory(t) {\n    return (ɵCdkMenuItemSelectable_BaseFactory || (ɵCdkMenuItemSelectable_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemSelectable)))(t || CdkMenuItemSelectable);\n  };\n}();\nCdkMenuItemSelectable.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItemSelectable,\n  hostVars: 2,\n  hostBindings: function CdkMenuItemSelectable_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-checked\", !!ctx.checked)(\"aria-disabled\", ctx.disabled || null);\n    }\n  },\n  inputs: {\n    checked: [\"cdkMenuItemChecked\", \"checked\"]\n  },\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemSelectable, [{\n    type: Directive,\n    args: [{\n      host: {\n        '[attr.aria-checked]': '!!checked',\n        '[attr.aria-disabled]': 'disabled || null'\n      }\n    }]\n  }], null, {\n    checked: [{\n      type: Input,\n      args: ['cdkMenuItemChecked']\n    }]\n  });\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** Counter used to set a unique id and name for a selectable item */\nlet nextId = 0;\n/**\r\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\r\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\r\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\r\n */\nclass CdkMenuItemRadio extends CdkMenuItemSelectable {\n  constructor() {\n    super();\n    /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\n    this._selectionDispatcher = inject(UniqueSelectionDispatcher);\n    /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\n    this._id = `${nextId++}`;\n    this._registerDispatcherListener();\n  }\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    this._removeDispatcherListener();\n  }\n  /**\r\n   * Toggles the checked state of the radio-button.\r\n   * @param options Options the configure how the item is triggered\r\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\r\n   */\n  trigger(options) {\n    super.trigger(options);\n    if (!this.disabled) {\n      this._selectionDispatcher.notify(this._id, '');\n    }\n  }\n  /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\n  _registerDispatcherListener() {\n    this._removeDispatcherListener = this._selectionDispatcher.listen(id => {\n      this.checked = this._id === id;\n    });\n  }\n}\nCdkMenuItemRadio.ɵfac = function CdkMenuItemRadio_Factory(t) {\n  return new (t || CdkMenuItemRadio)();\n};\nCdkMenuItemRadio.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItemRadio,\n  selectors: [[\"\", \"cdkMenuItemRadio\", \"\"]],\n  hostAttrs: [\"role\", \"menuitemradio\"],\n  hostVars: 2,\n  hostBindings: function CdkMenuItemRadio_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"cdk-menu-item-radio\", true);\n    }\n  },\n  exportAs: [\"cdkMenuItemRadio\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuItemSelectable,\n    useExisting: CdkMenuItemRadio\n  }, {\n    provide: CdkMenuItem,\n    useExisting: CdkMenuItemSelectable\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemRadio, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItemRadio]',\n      exportAs: 'cdkMenuItemRadio',\n      standalone: true,\n      host: {\n        'role': 'menuitemradio',\n        '[class.cdk-menu-item-radio]': 'true'\n      },\n      providers: [{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemRadio\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/**\r\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\r\n * conventional checkbox.\r\n */\nclass CdkMenuItemCheckbox extends CdkMenuItemSelectable {\n  /**\r\n   * Toggle the checked state of the checkbox.\r\n   * @param options Options the configure how the item is triggered\r\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\r\n   */\n  trigger(options) {\n    super.trigger(options);\n    if (!this.disabled) {\n      this.checked = !this.checked;\n    }\n  }\n}\nCdkMenuItemCheckbox.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuItemCheckbox_BaseFactory;\n  return function CdkMenuItemCheckbox_Factory(t) {\n    return (ɵCdkMenuItemCheckbox_BaseFactory || (ɵCdkMenuItemCheckbox_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemCheckbox)))(t || CdkMenuItemCheckbox);\n  };\n}();\nCdkMenuItemCheckbox.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItemCheckbox,\n  selectors: [[\"\", \"cdkMenuItemCheckbox\", \"\"]],\n  hostAttrs: [\"role\", \"menuitemcheckbox\"],\n  hostVars: 2,\n  hostBindings: function CdkMenuItemCheckbox_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"cdk-menu-item-checkbox\", true);\n    }\n  },\n  exportAs: [\"cdkMenuItemCheckbox\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuItemSelectable,\n    useExisting: CdkMenuItemCheckbox\n  }, {\n    provide: CdkMenuItem,\n    useExisting: CdkMenuItemSelectable\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemCheckbox, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItemCheckbox]',\n      exportAs: 'cdkMenuItemCheckbox',\n      standalone: true,\n      host: {\n        'role': 'menuitemcheckbox',\n        '[class.cdk-menu-item-checkbox]': 'true'\n      },\n      providers: [{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemCheckbox\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]\n    }]\n  }], null, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n/** The preferred menu positions for the context menu. */\nconst CONTEXT_MENU_POSITIONS = STANDARD_DROPDOWN_BELOW_POSITIONS.map(position => {\n  // In cases where the first menu item in the context menu is a trigger the submenu opens on a\n  // hover event. We offset the context menu 2px by default to prevent this from occurring.\n  const offsetX = position.overlayX === 'start' ? 2 : -2;\n  const offsetY = position.overlayY === 'top' ? 2 : -2;\n  return {\n    ...position,\n    offsetX,\n    offsetY\n  };\n});\n/** Tracks the last open context menu trigger across the entire application. */\nclass ContextMenuTracker {\n  /**\r\n   * Close the previous open context menu and set the given one as being open.\r\n   * @param trigger The trigger for the currently open Context Menu.\r\n   */\n  update(trigger) {\n    if (ContextMenuTracker._openContextMenuTrigger !== trigger) {\n      ContextMenuTracker._openContextMenuTrigger?.close();\n      ContextMenuTracker._openContextMenuTrigger = trigger;\n    }\n  }\n}\nContextMenuTracker.ɵfac = function ContextMenuTracker_Factory(t) {\n  return new (t || ContextMenuTracker)();\n};\nContextMenuTracker.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ContextMenuTracker,\n  factory: ContextMenuTracker.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ContextMenuTracker, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\r\n * A directive that opens a menu when a user right-clicks within its host element.\r\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\r\n */\nclass CdkContextMenuTrigger extends CdkMenuTriggerBase {\n  /** Whether the context menu is disabled. */\n  get disabled() {\n    return this._disabled;\n  }\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  constructor() {\n    super();\n    /** The CDK overlay service. */\n    this._overlay = inject(Overlay);\n    /** The directionality of the page. */\n    this._directionality = inject(Directionality, {\n      optional: true\n    });\n    /** The app's context menu tracking registry */\n    this._contextMenuTracker = inject(ContextMenuTracker);\n    this._disabled = false;\n    this._setMenuStackCloseListener();\n  }\n  /**\r\n   * Open the attached menu at the specified location.\r\n   * @param coordinates where to open the context menu\r\n   */\n  open(coordinates) {\n    this._open(coordinates, false);\n  }\n  /** Close the currently opened context menu. */\n  close() {\n    this.menuStack.closeAll();\n  }\n  /**\r\n   * Open the context menu and closes any previously open menus.\r\n   * @param event the mouse event which opens the context menu.\r\n   */\n  _openOnContextMenu(event) {\n    if (!this.disabled) {\n      // Prevent the native context menu from opening because we're opening a custom one.\n      event.preventDefault();\n      // Stop event propagation to ensure that only the closest enabled context menu opens.\n      // Otherwise, any context menus attached to containing elements would *also* open,\n      // resulting in multiple stacked context menus being displayed.\n      event.stopPropagation();\n      this._contextMenuTracker.update(this);\n      this._open({\n        x: event.clientX,\n        y: event.clientY\n      }, true);\n      // A context menu can be triggered via a mouse right click or a keyboard shortcut.\n      if (event.button === 2) {\n        this.childMenu?.focusFirstItem('mouse');\n      } else if (event.button === 0) {\n        this.childMenu?.focusFirstItem('keyboard');\n      } else {\n        this.childMenu?.focusFirstItem('program');\n      }\n    }\n  }\n  /**\r\n   * Get the configuration object used to create the overlay.\r\n   * @param coordinates the location to place the opened menu\r\n   */\n  _getOverlayConfig(coordinates) {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(coordinates),\n      scrollStrategy: this._overlay.scrollStrategies.reposition(),\n      direction: this._directionality || undefined\n    });\n  }\n  /**\r\n   * Get the position strategy for the overlay which specifies where to place the menu.\r\n   * @param coordinates the location to place the opened menu\r\n   */\n  _getOverlayPositionStrategy(coordinates) {\n    return this._overlay.position().flexibleConnectedTo(coordinates).withLockedPosition().withGrowAfterOpen().withPositions(this.menuPosition ?? CONTEXT_MENU_POSITIONS);\n  }\n  /** Subscribe to the menu stack close events and close this menu when requested. */\n  _setMenuStackCloseListener() {\n    this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n      item\n    }) => {\n      if (item === this.childMenu && this.isOpen()) {\n        this.closed.next();\n        this.overlayRef.detach();\n      }\n    });\n  }\n  /**\r\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\r\n   * click occurs outside the menus.\r\n   * @param ignoreFirstAuxClick Whether to ignore the first auxclick event outside the menu.\r\n   */\n  _subscribeToOutsideClicks(ignoreFirstAuxClick) {\n    if (this.overlayRef) {\n      let outsideClicks = this.overlayRef.outsidePointerEvents();\n      // If the menu was triggered by the `contextmenu` event, skip the first `auxclick` event\n      // because it fires when the mouse is released on the same click that opened the menu.\n      if (ignoreFirstAuxClick) {\n        const [auxClicks, nonAuxClicks] = partition(outsideClicks, ({\n          type\n        }) => type === 'auxclick');\n        outsideClicks = merge(nonAuxClicks, auxClicks.pipe(skip(1)));\n      }\n      outsideClicks.pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n        if (!this.isElementInsideMenuStack(_getEventTarget(event))) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n  /**\r\n   * Open the attached menu at the specified location.\r\n   * @param coordinates where to open the context menu\r\n   * @param ignoreFirstOutsideAuxClick Whether to ignore the first auxclick outside the menu after opening.\r\n   */\n  _open(coordinates, ignoreFirstOutsideAuxClick) {\n    if (this.disabled) {\n      return;\n    }\n    if (this.isOpen()) {\n      // since we're moving this menu we need to close any submenus first otherwise they end up\n      // disconnected from this one.\n      this.menuStack.closeSubMenuOf(this.childMenu);\n      this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n      this.overlayRef.updatePosition();\n    } else {\n      this.opened.next();\n      if (this.overlayRef) {\n        this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n        this.overlayRef.updatePosition();\n      } else {\n        this.overlayRef = this._overlay.create(this._getOverlayConfig(coordinates));\n      }\n      this.overlayRef.attach(this.getMenuContentPortal());\n      this._subscribeToOutsideClicks(ignoreFirstOutsideAuxClick);\n    }\n  }\n}\nCdkContextMenuTrigger.ɵfac = function CdkContextMenuTrigger_Factory(t) {\n  return new (t || CdkContextMenuTrigger)();\n};\nCdkContextMenuTrigger.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkContextMenuTrigger,\n  selectors: [[\"\", \"cdkContextMenuTriggerFor\", \"\"]],\n  hostVars: 1,\n  hostBindings: function CdkContextMenuTrigger_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"contextmenu\", function CdkContextMenuTrigger_contextmenu_HostBindingHandler($event) {\n        return ctx._openOnContextMenu($event);\n      });\n    }\n    if (rf & 2) {\n      i0.ɵɵattribute(\"data-cdk-menu-stack-id\", null);\n    }\n  },\n  inputs: {\n    menuTemplateRef: [\"cdkContextMenuTriggerFor\", \"menuTemplateRef\"],\n    menuPosition: [\"cdkContextMenuPosition\", \"menuPosition\"],\n    menuData: [\"cdkContextMenuTriggerData\", \"menuData\"],\n    disabled: [\"cdkContextMenuDisabled\", \"disabled\"]\n  },\n  outputs: {\n    opened: \"cdkContextMenuOpened\",\n    closed: \"cdkContextMenuClosed\"\n  },\n  exportAs: [\"cdkContextMenuTriggerFor\"],\n  standalone: true,\n  features: [i0.ɵɵProvidersFeature([{\n    provide: MENU_TRIGGER,\n    useExisting: CdkContextMenuTrigger\n  }, {\n    provide: MENU_STACK,\n    useClass: MenuStack\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkContextMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkContextMenuTriggerFor]',\n      exportAs: 'cdkContextMenuTriggerFor',\n      standalone: true,\n      host: {\n        '[attr.data-cdk-menu-stack-id]': 'null',\n        '(contextmenu)': '_openOnContextMenu($event)'\n      },\n      inputs: ['menuTemplateRef: cdkContextMenuTriggerFor', 'menuPosition: cdkContextMenuPosition', 'menuData: cdkContextMenuTriggerData'],\n      outputs: ['opened: cdkContextMenuOpened', 'closed: cdkContextMenuClosed'],\n      providers: [{\n        provide: MENU_TRIGGER,\n        useExisting: CdkContextMenuTrigger\n      }, {\n        provide: MENU_STACK,\n        useClass: MenuStack\n      }]\n    }]\n  }], function () {\n    return [];\n  }, {\n    disabled: [{\n      type: Input,\n      args: ['cdkContextMenuDisabled']\n    }]\n  });\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\nconst MENU_DIRECTIVES = [CdkMenuBar, CdkMenu, CdkMenuItem, CdkMenuItemRadio, CdkMenuItemCheckbox, CdkMenuTrigger, CdkMenuGroup, CdkContextMenuTrigger, CdkTargetMenuAim];\n/** Module that declares components and directives for the CDK menu. */\nclass CdkMenuModule {}\nCdkMenuModule.ɵfac = function CdkMenuModule_Factory(t) {\n  return new (t || CdkMenuModule)();\n};\nCdkMenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: CdkMenuModule\n});\nCdkMenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [OverlayModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuModule, [{\n    type: NgModule,\n    args: [{\n      imports: [OverlayModule, ...MENU_DIRECTIVES],\n      exports: MENU_DIRECTIVES\n    }]\n  }], null, null);\n})();\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CDK_MENU, CdkContextMenuTrigger, CdkMenu, CdkMenuBar, CdkMenuBase, CdkMenuGroup, CdkMenuItem, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItemSelectable, CdkMenuModule, CdkMenuTrigger, CdkMenuTriggerBase, CdkTargetMenuAim, ContextMenuTracker, MENU_AIM, MENU_STACK, MENU_TRIGGER, MenuStack, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER, PARENT_OR_NEW_MENU_STACK_PROVIDER, PointerFocusTracker, TargetMenuAim };","map":{"version":3,"names":["i0","Directive","InjectionToken","Optional","SkipSelf","Inject","Injectable","inject","Injector","ViewContainerRef","EventEmitter","NgZone","ElementRef","Input","Output","ContentChildren","NgModule","Overlay","OverlayConfig","STANDARD_DROPDOWN_BELOW_POSITIONS","STANDARD_DROPDOWN_ADJACENT_POSITIONS","OverlayModule","UP_ARROW","hasModifierKey","DOWN_ARROW","LEFT_ARROW","RIGHT_ARROW","ENTER","SPACE","TAB","ESCAPE","startWith","debounceTime","distinctUntilChanged","filter","takeUntil","mergeMap","mapTo","mergeAll","switchMap","skip","UniqueSelectionDispatcher","Subject","merge","fromEvent","defer","partition","TemplatePortal","InputModalityDetector","FocusKeyManager","coerceBooleanProperty","Directionality","_getEventTarget","CdkMenuGroup","ɵfac","ɵdir","provide","useClass","type","args","selector","exportAs","standalone","host","providers","CDK_MENU","MENU_STACK","PARENT_OR_NEW_MENU_STACK_PROVIDER","deps","useFactory","parentMenuStack","MenuStack","PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER","orientation","inline","nextId$2","constructor","id","_elements","_close","_empty","_hasFocus","closed","hasFocus","pipe","emptied","_inlineMenuOrientation","stack","push","menu","close","lastItem","options","focusNextOnEmpty","focusParentTrigger","indexOf","poppedElement","pop","next","item","isEmpty","closeSubMenuOf","removed","peek","closeAll","menuStackItem","length","hasInlineMenu","inlineMenuOrientation","setHasFocus","ɵprov","MENU_TRIGGER","CdkMenuTriggerBase","injector","viewContainerRef","menuStack","opened","overlayRef","destroyed","stopOutsideClicksListener","ngOnDestroy","_destroyOverlay","complete","isOpen","hasAttached","registerChildMenu","child","childMenu","getMenuContentPortal","hasMenuContentChanged","menuTemplateRef","_menuPortal","templateRef","menuData","_getChildMenuInjector","isElementInsideMenuStack","element","el","parentElement","getAttribute","dispose","_childMenuInjector","create","useValue","parent","throwMissingPointerFocusTracker","Error","throwMissingMenuReference","MENU_AIM","MOUSE_MOVE_SAMPLE_FREQUENCY","NUM_POINTS","CLOSE_DELAY","getSlope","a","b","y","x","getYIntercept","point","slope","isWithinSubmenu","submenuPoints","m","left","right","top","bottom","TargetMenuAim","_ngZone","_points","_destroyed","initialize","pointerTracker","_menu","_pointerTracker","_subscribeToMouseMoves","toggle","doToggle","_checkConfigured","siblingItemIsWaiting","_timeoutId","hasPoints","_isMovingToSubmenu","_startTimeout","timeoutId","setTimeout","activeElement","_getSubmenuBounds","numMoving","currPoint","i","previous","Math","floor","previousElement","getMenu","nativeElement","getBoundingClientRect","ngDevMode","runOutsideAngular","_","index","subscribe","event","clientX","clientY","shift","CdkTargetMenuAim","CdkMenuTrigger","_elementRef","_overlay","_directionality","optional","_inputModalityDetector","_parentMenu","_menuAim","_setRole","_registerCloseHandler","_subscribeToMenuStackClosed","_subscribeToMouseEnter","_subscribeToMenuStackHasFocus","_setType","open","_getOverlayConfig","attach","_subscribeToOutsideClicks","detach","_closeSiblingTriggers","_toggleOnKeydown","isParentVertical","keyCode","focusFirstItem","value","preventDefault","focusLastItem","_handleClick","mostRecentModality","_setHasFocus","toggleMenus","run","isParentMenuBar","positionStrategy","_getOverlayPositionStrategy","scrollStrategy","scrollStrategies","reposition","direction","undefined","position","flexibleConnectedTo","withLockedPosition","withGrowAfterOpen","withPositions","_getOverlayPositions","menuPosition","outsidePointerEvents","target","contains","focus","setAttribute","nodeName","useExisting","inputs","outputs","CdkMenuItem","disabled","_disabled","hasMenu","_menuTrigger","_dir","_menuStack","self","triggered","_tabindex","closeOnSpacebarTrigger","_setupMouseEnter","_isStandaloneItem","trigger","keepOpen","isMenuOpen","getMenuTrigger","getLabel","typeaheadLabel","textContent","trim","_resetTabIndex","_setTabIndex","_onKeydown","_isParentVertical","_forwardArrowPressed","_backArrowPressed","parentMenu","closeOpenSiblings","PointerFocusTracker","_items","entered","_getItemPointerEntries","exited","_getItemPointerExits","destroy","changes","list","map","nextId$1","CdkMenuBase","arguments","ngZone","menuAim","dir","isInline","_menuStackHasFocus","ngAfterContentInit","_setKeyManager","_subscribeToMenuOpen","_setUpPointerTracker","keyManager","focusOrigin","setFocusOrigin","setFirstItemActive","setLastItemActive","_getTabIndex","tabindexIfInline","closeOpenMenu","triggerItem","setActiveItem","items","withWrap","withTypeAhead","withHomeAndEnd","withHorizontalOrientation","withVerticalOrientation","exitCondition","descendants","CdkMenu","_parentTrigger","_subscribeToMenuStackEmptied","_handleKeyEvent","onKeydown","_toggleMenuFocus","focusNext","setNextItemActive","setPreviousItemActive","activeItem","CdkMenuBar","horizontalArrows","prevIsOpen","_toggleOpenMenu","CdkMenuItemSelectable","_checked","checked","nextId","CdkMenuItemRadio","_selectionDispatcher","_id","_registerDispatcherListener","_removeDispatcherListener","notify","listen","CdkMenuItemCheckbox","CONTEXT_MENU_POSITIONS","offsetX","overlayX","offsetY","overlayY","ContextMenuTracker","update","_openContextMenuTrigger","providedIn","CdkContextMenuTrigger","_contextMenuTracker","_setMenuStackCloseListener","coordinates","_open","_openOnContextMenu","stopPropagation","button","ignoreFirstAuxClick","outsideClicks","auxClicks","nonAuxClicks","ignoreFirstOutsideAuxClick","getConfig","setOrigin","updatePosition","MENU_DIRECTIVES","CdkMenuModule","ɵmod","ɵinj","imports","exports"],"sources":["C:/atv-app/node_modules/@angular/cdk/fesm2020/menu.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\r\nimport { Directive, InjectionToken, Optional, SkipSelf, Inject, Injectable, inject, Injector, ViewContainerRef, EventEmitter, NgZone, ElementRef, Input, Output, ContentChildren, NgModule } from '@angular/core';\r\nimport { Overlay, OverlayConfig, STANDARD_DROPDOWN_BELOW_POSITIONS, STANDARD_DROPDOWN_ADJACENT_POSITIONS, OverlayModule } from '@angular/cdk/overlay';\r\nimport { UP_ARROW, hasModifierKey, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, TAB, ESCAPE } from '@angular/cdk/keycodes';\r\nimport { startWith, debounceTime, distinctUntilChanged, filter, takeUntil, mergeMap, mapTo, mergeAll, switchMap, skip } from 'rxjs/operators';\r\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\r\nimport { Subject, merge, fromEvent, defer, partition } from 'rxjs';\r\nimport { TemplatePortal } from '@angular/cdk/portal';\r\nimport { InputModalityDetector, FocusKeyManager } from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { _getEventTarget } from '@angular/cdk/platform';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\r\n */\r\nclass CdkMenuGroup {\r\n}\r\nCdkMenuGroup.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuGroup, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuGroup.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuGroup, isStandalone: true, selector: \"[cdkMenuGroup]\", host: { attributes: { \"role\": \"group\" }, classAttribute: \"cdk-menu-group\" }, providers: [{ provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher }], exportAs: [\"cdkMenuGroup\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuGroup, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMenuGroup]',\r\n                    exportAs: 'cdkMenuGroup',\r\n                    standalone: true,\r\n                    host: {\r\n                        'role': 'group',\r\n                        'class': 'cdk-menu-group',\r\n                    },\r\n                    providers: [{ provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher }],\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token used to return classes implementing the Menu interface */\r\nconst CDK_MENU = new InjectionToken('cdk-menu');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token used for an implementation of MenuStack. */\r\nconst MENU_STACK = new InjectionToken('cdk-menu-stack');\r\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\r\nconst PARENT_OR_NEW_MENU_STACK_PROVIDER = {\r\n    provide: MENU_STACK,\r\n    deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\r\n    useFactory: (parentMenuStack) => parentMenuStack || new MenuStack(),\r\n};\r\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\r\nconst PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER = (orientation) => ({\r\n    provide: MENU_STACK,\r\n    deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\r\n    useFactory: (parentMenuStack) => parentMenuStack || MenuStack.inline(orientation),\r\n});\r\n/** The next available menu stack ID. */\r\nlet nextId$2 = 0;\r\n/**\r\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\r\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\r\n * from the `empty` observable specifying the next focus action which the listener should perform\r\n * as requested by the closer.\r\n */\r\nclass MenuStack {\r\n    constructor() {\r\n        /** The ID of this menu stack. */\r\n        this.id = `${nextId$2++}`;\r\n        /** All MenuStackItems tracked by this MenuStack. */\r\n        this._elements = [];\r\n        /** Emits the element which was popped off of the stack when requested by a closer. */\r\n        this._close = new Subject();\r\n        /** Emits once the MenuStack has become empty after popping off elements. */\r\n        this._empty = new Subject();\r\n        /** Emits whether any menu in the menu stack has focus. */\r\n        this._hasFocus = new Subject();\r\n        /** Observable which emits the MenuStackItem which has been requested to close. */\r\n        this.closed = this._close;\r\n        /** Observable which emits whether any menu in the menu stack has focus. */\r\n        this.hasFocus = this._hasFocus.pipe(startWith(false), debounceTime(0), distinctUntilChanged());\r\n        /**\r\n         * Observable which emits when the MenuStack is empty after popping off the last element. It\r\n         * emits a FocusNext event which specifies the action the closer has requested the listener\r\n         * perform.\r\n         */\r\n        this.emptied = this._empty;\r\n        /**\r\n         * Whether the inline menu associated with this menu stack is vertical or horizontal.\r\n         * `null` indicates there is no inline menu associated with this menu stack.\r\n         */\r\n        this._inlineMenuOrientation = null;\r\n    }\r\n    /** Creates a menu stack that originates from an inline menu. */\r\n    static inline(orientation) {\r\n        const stack = new MenuStack();\r\n        stack._inlineMenuOrientation = orientation;\r\n        return stack;\r\n    }\r\n    /**\r\n     * Adds an item to the menu stack.\r\n     * @param menu the MenuStackItem to put on the stack.\r\n     */\r\n    push(menu) {\r\n        this._elements.push(menu);\r\n    }\r\n    /**\r\n     * Pop items off of the stack up to and including `lastItem` and emit each on the close\r\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\r\n     * @param lastItem the last item to pop off the stack.\r\n     * @param options Options that configure behavior on close.\r\n     */\r\n    close(lastItem, options) {\r\n        const { focusNextOnEmpty, focusParentTrigger } = { ...options };\r\n        if (this._elements.indexOf(lastItem) >= 0) {\r\n            let poppedElement;\r\n            do {\r\n                poppedElement = this._elements.pop();\r\n                this._close.next({ item: poppedElement, focusParentTrigger });\r\n            } while (poppedElement !== lastItem);\r\n            if (this.isEmpty()) {\r\n                this._empty.next(focusNextOnEmpty);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\r\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\r\n     * @param lastItem the element which should be left on the stack\r\n     * @return whether or not an item was removed from the stack\r\n     */\r\n    closeSubMenuOf(lastItem) {\r\n        let removed = false;\r\n        if (this._elements.indexOf(lastItem) >= 0) {\r\n            removed = this.peek() !== lastItem;\r\n            while (this.peek() !== lastItem) {\r\n                this._close.next({ item: this._elements.pop() });\r\n            }\r\n        }\r\n        return removed;\r\n    }\r\n    /**\r\n     * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\r\n     * @param options Options that configure behavior on close.\r\n     */\r\n    closeAll(options) {\r\n        const { focusNextOnEmpty, focusParentTrigger } = { ...options };\r\n        if (!this.isEmpty()) {\r\n            while (!this.isEmpty()) {\r\n                const menuStackItem = this._elements.pop();\r\n                if (menuStackItem) {\r\n                    this._close.next({ item: menuStackItem, focusParentTrigger });\r\n                }\r\n            }\r\n            this._empty.next(focusNextOnEmpty);\r\n        }\r\n    }\r\n    /** Return true if this stack is empty. */\r\n    isEmpty() {\r\n        return !this._elements.length;\r\n    }\r\n    /** Return the length of the stack. */\r\n    length() {\r\n        return this._elements.length;\r\n    }\r\n    /** Get the top most element on the stack. */\r\n    peek() {\r\n        return this._elements[this._elements.length - 1];\r\n    }\r\n    /** Whether the menu stack is associated with an inline menu. */\r\n    hasInlineMenu() {\r\n        return this._inlineMenuOrientation != null;\r\n    }\r\n    /** The orientation of the associated inline menu. */\r\n    inlineMenuOrientation() {\r\n        return this._inlineMenuOrientation;\r\n    }\r\n    /** Sets whether the menu stack contains the focused element. */\r\n    setHasFocus(hasFocus) {\r\n        this._hasFocus.next(hasFocus);\r\n    }\r\n}\r\nMenuStack.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: MenuStack, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nMenuStack.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: MenuStack });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: MenuStack, decorators: [{\r\n            type: Injectable\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token used for an implementation of MenuStack. */\r\nconst MENU_TRIGGER = new InjectionToken('cdk-menu-trigger');\r\n/**\r\n * Abstract directive that implements shared logic common to all menu triggers.\r\n * This class can be extended to create custom menu trigger types.\r\n */\r\nclass CdkMenuTriggerBase {\r\n    constructor() {\r\n        /** The DI injector for this component. */\r\n        this.injector = inject(Injector);\r\n        /** The view container ref for this component */\r\n        this.viewContainerRef = inject(ViewContainerRef);\r\n        /** The menu stack in which this menu resides. */\r\n        this.menuStack = inject(MENU_STACK);\r\n        /** Emits when the attached menu is requested to open */\r\n        this.opened = new EventEmitter();\r\n        /** Emits when the attached menu is requested to close */\r\n        this.closed = new EventEmitter();\r\n        /** A reference to the overlay which manages the triggered menu */\r\n        this.overlayRef = null;\r\n        /** Emits when this trigger is destroyed. */\r\n        this.destroyed = new Subject();\r\n        /** Emits when the outside pointer events listener on the overlay should be stopped. */\r\n        this.stopOutsideClicksListener = merge(this.closed, this.destroyed);\r\n    }\r\n    ngOnDestroy() {\r\n        this._destroyOverlay();\r\n        this.destroyed.next();\r\n        this.destroyed.complete();\r\n    }\r\n    /** Whether the attached menu is open. */\r\n    isOpen() {\r\n        return !!this.overlayRef?.hasAttached();\r\n    }\r\n    /** Registers a child menu as having been opened by this trigger. */\r\n    registerChildMenu(child) {\r\n        this.childMenu = child;\r\n    }\r\n    /**\r\n     * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\r\n     * content to change dynamically and be reflected in the application.\r\n     */\r\n    getMenuContentPortal() {\r\n        const hasMenuContentChanged = this.menuTemplateRef !== this._menuPortal?.templateRef;\r\n        if (this.menuTemplateRef && (!this._menuPortal || hasMenuContentChanged)) {\r\n            this._menuPortal = new TemplatePortal(this.menuTemplateRef, this.viewContainerRef, this.menuData, this._getChildMenuInjector());\r\n        }\r\n        return this._menuPortal;\r\n    }\r\n    /**\r\n     * Whether the given element is inside the scope of this trigger's menu stack.\r\n     * @param element The element to check.\r\n     * @return Whether the element is inside the scope of this trigger's menu stack.\r\n     */\r\n    isElementInsideMenuStack(element) {\r\n        for (let el = element; el; el = el?.parentElement ?? null) {\r\n            if (el.getAttribute('data-cdk-menu-stack-id') === this.menuStack.id) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /** Destroy and unset the overlay reference it if exists */\r\n    _destroyOverlay() {\r\n        if (this.overlayRef) {\r\n            this.overlayRef.dispose();\r\n            this.overlayRef = null;\r\n        }\r\n    }\r\n    /** Gets the injector to use when creating a child menu. */\r\n    _getChildMenuInjector() {\r\n        this._childMenuInjector =\r\n            this._childMenuInjector ||\r\n                Injector.create({\r\n                    providers: [\r\n                        { provide: MENU_TRIGGER, useValue: this },\r\n                        { provide: MENU_STACK, useValue: this.menuStack },\r\n                    ],\r\n                    parent: this.injector,\r\n                });\r\n        return this._childMenuInjector;\r\n    }\r\n}\r\nCdkMenuTriggerBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuTriggerBase, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuTriggerBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuTriggerBase, host: { properties: { \"attr.aria-controls\": \"childMenu?.id\", \"attr.data-cdk-menu-stack-id\": \"menuStack.id\" } }, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuTriggerBase, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    host: {\r\n                        '[attr.aria-controls]': 'childMenu?.id',\r\n                        '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\r\n                    },\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Throws an exception when an instance of the PointerFocusTracker is not provided.\r\n * @docs-private\r\n */\r\nfunction throwMissingPointerFocusTracker() {\r\n    throw Error('expected an instance of PointerFocusTracker to be provided');\r\n}\r\n/**\r\n * Throws an exception when a reference to the parent menu is not provided.\r\n * @docs-private\r\n */\r\nfunction throwMissingMenuReference() {\r\n    throw Error('expected a reference to the parent menu');\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token used for an implementation of MenuAim. */\r\nconst MENU_AIM = new InjectionToken('cdk-menu-aim');\r\n/** Capture every nth mouse move event. */\r\nconst MOUSE_MOVE_SAMPLE_FREQUENCY = 3;\r\n/** The number of mouse move events to track. */\r\nconst NUM_POINTS = 5;\r\n/**\r\n * How long to wait before closing a sibling menu if a user stops short of the submenu they were\r\n * predicted to go into.\r\n */\r\nconst CLOSE_DELAY = 300;\r\n/** Calculate the slope between point a and b. */\r\nfunction getSlope(a, b) {\r\n    return (b.y - a.y) / (b.x - a.x);\r\n}\r\n/** Calculate the y intercept for the given point and slope. */\r\nfunction getYIntercept(point, slope) {\r\n    return point.y - slope * point.x;\r\n}\r\n/**\r\n * Whether the given mouse trajectory line defined by the slope and y intercept falls within the\r\n * submenu as defined by `submenuPoints`\r\n * @param submenuPoints the submenu DOMRect points.\r\n * @param m the slope of the trajectory line.\r\n * @param b the y intercept of the trajectory line.\r\n * @return true if any point on the line falls within the submenu.\r\n */\r\nfunction isWithinSubmenu(submenuPoints, m, b) {\r\n    const { left, right, top, bottom } = submenuPoints;\r\n    // Check for intersection with each edge of the submenu (left, right, top, bottom)\r\n    // by fixing one coordinate to that edge's coordinate (either x or y) and checking if the\r\n    // other coordinate is within bounds.\r\n    return ((m * left + b >= top && m * left + b <= bottom) ||\r\n        (m * right + b >= top && m * right + b <= bottom) ||\r\n        ((top - b) / m >= left && (top - b) / m <= right) ||\r\n        ((bottom - b) / m >= left && (bottom - b) / m <= right));\r\n}\r\n/**\r\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\r\n * trajectory of the user's mouse movement in the current menu to determine if the\r\n * mouse is moving towards an open submenu.\r\n *\r\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\r\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\r\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\r\n * to submenu.\r\n */\r\nclass TargetMenuAim {\r\n    constructor() {\r\n        /** The Angular zone. */\r\n        this._ngZone = inject(NgZone);\r\n        /** The last NUM_POINTS mouse move events. */\r\n        this._points = [];\r\n        /** Emits when this service is destroyed. */\r\n        this._destroyed = new Subject();\r\n    }\r\n    ngOnDestroy() {\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /**\r\n     * Set the Menu and its PointerFocusTracker.\r\n     * @param menu The menu that this menu aim service controls.\r\n     * @param pointerTracker The `PointerFocusTracker` for the given menu.\r\n     */\r\n    initialize(menu, pointerTracker) {\r\n        this._menu = menu;\r\n        this._pointerTracker = pointerTracker;\r\n        this._subscribeToMouseMoves();\r\n    }\r\n    /**\r\n     * Calls the `doToggle` callback when it is deemed that the user is not moving towards\r\n     * the submenu.\r\n     * @param doToggle the function called when the user is not moving towards the submenu.\r\n     */\r\n    toggle(doToggle) {\r\n        // If the menu is horizontal the sub-menus open below and there is no risk of premature\r\n        // closing of any sub-menus therefore we automatically resolve the callback.\r\n        if (this._menu.orientation === 'horizontal') {\r\n            doToggle();\r\n        }\r\n        this._checkConfigured();\r\n        const siblingItemIsWaiting = !!this._timeoutId;\r\n        const hasPoints = this._points.length > 1;\r\n        if (hasPoints && !siblingItemIsWaiting) {\r\n            if (this._isMovingToSubmenu()) {\r\n                this._startTimeout(doToggle);\r\n            }\r\n            else {\r\n                doToggle();\r\n            }\r\n        }\r\n        else if (!siblingItemIsWaiting) {\r\n            doToggle();\r\n        }\r\n    }\r\n    /**\r\n     * Start the delayed toggle handler if one isn't running already.\r\n     *\r\n     * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\r\n     * users mouse is on an item in the current menu.\r\n     *\r\n     * @param doToggle the function called when the user is not moving towards the submenu.\r\n     */\r\n    _startTimeout(doToggle) {\r\n        // If the users mouse is moving towards a submenu we don't want to immediately resolve.\r\n        // Wait for some period of time before determining if the previous menu should close in\r\n        // cases where the user may have moved towards the submenu but stopped on a sibling menu\r\n        // item intentionally.\r\n        const timeoutId = setTimeout(() => {\r\n            // Resolve if the user is currently moused over some element in the root menu\r\n            if (this._pointerTracker.activeElement && timeoutId === this._timeoutId) {\r\n                doToggle();\r\n            }\r\n            this._timeoutId = null;\r\n        }, CLOSE_DELAY);\r\n        this._timeoutId = timeoutId;\r\n    }\r\n    /** Whether the user is heading towards the open submenu. */\r\n    _isMovingToSubmenu() {\r\n        const submenuPoints = this._getSubmenuBounds();\r\n        if (!submenuPoints) {\r\n            return false;\r\n        }\r\n        let numMoving = 0;\r\n        const currPoint = this._points[this._points.length - 1];\r\n        // start from the second last point and calculate the slope between each point and the last\r\n        // point.\r\n        for (let i = this._points.length - 2; i >= 0; i--) {\r\n            const previous = this._points[i];\r\n            const slope = getSlope(currPoint, previous);\r\n            if (isWithinSubmenu(submenuPoints, slope, getYIntercept(currPoint, slope))) {\r\n                numMoving++;\r\n            }\r\n        }\r\n        return numMoving >= Math.floor(NUM_POINTS / 2);\r\n    }\r\n    /** Get the bounding DOMRect for the open submenu. */\r\n    _getSubmenuBounds() {\r\n        return this._pointerTracker?.previousElement?.getMenu()?.nativeElement.getBoundingClientRect();\r\n    }\r\n    /**\r\n     * Check if a reference to the PointerFocusTracker and menu element is provided.\r\n     * @throws an error if neither reference is provided.\r\n     */\r\n    _checkConfigured() {\r\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n            if (!this._pointerTracker) {\r\n                throwMissingPointerFocusTracker();\r\n            }\r\n            if (!this._menu) {\r\n                throwMissingMenuReference();\r\n            }\r\n        }\r\n    }\r\n    /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\r\n    _subscribeToMouseMoves() {\r\n        this._ngZone.runOutsideAngular(() => {\r\n            fromEvent(this._menu.nativeElement, 'mousemove')\r\n                .pipe(filter((_, index) => index % MOUSE_MOVE_SAMPLE_FREQUENCY === 0), takeUntil(this._destroyed))\r\n                .subscribe((event) => {\r\n                this._points.push({ x: event.clientX, y: event.clientY });\r\n                if (this._points.length > NUM_POINTS) {\r\n                    this._points.shift();\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nTargetMenuAim.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: TargetMenuAim, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nTargetMenuAim.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: TargetMenuAim });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: TargetMenuAim, decorators: [{\r\n            type: Injectable\r\n        }] });\r\n/**\r\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\r\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\r\n */\r\nclass CdkTargetMenuAim {\r\n}\r\nCdkTargetMenuAim.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkTargetMenuAim, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkTargetMenuAim.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkTargetMenuAim, isStandalone: true, selector: \"[cdkTargetMenuAim]\", providers: [{ provide: MENU_AIM, useClass: TargetMenuAim }], exportAs: [\"cdkTargetMenuAim\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkTargetMenuAim, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkTargetMenuAim]',\r\n                    exportAs: 'cdkTargetMenuAim',\r\n                    standalone: true,\r\n                    providers: [{ provide: MENU_AIM, useClass: TargetMenuAim }],\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A directive that turns its host element into a trigger for a popup menu.\r\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\r\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\r\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\r\n * state.\r\n */\r\nclass CdkMenuTrigger extends CdkMenuTriggerBase {\r\n    constructor() {\r\n        super();\r\n        this._elementRef = inject(ElementRef);\r\n        this._overlay = inject(Overlay);\r\n        this._ngZone = inject(NgZone);\r\n        this._directionality = inject(Directionality, { optional: true });\r\n        this._inputModalityDetector = inject(InputModalityDetector);\r\n        /** The parent menu this trigger belongs to. */\r\n        this._parentMenu = inject(CDK_MENU, { optional: true });\r\n        /** The menu aim service used by this menu. */\r\n        this._menuAim = inject(MENU_AIM, { optional: true });\r\n        this._setRole();\r\n        this._registerCloseHandler();\r\n        this._subscribeToMenuStackClosed();\r\n        this._subscribeToMouseEnter();\r\n        this._subscribeToMenuStackHasFocus();\r\n        this._setType();\r\n    }\r\n    /** Toggle the attached menu. */\r\n    toggle() {\r\n        this.isOpen() ? this.close() : this.open();\r\n    }\r\n    /** Open the attached menu. */\r\n    open() {\r\n        if (!this.isOpen() && this.menuTemplateRef != null) {\r\n            this.opened.next();\r\n            this.overlayRef = this.overlayRef || this._overlay.create(this._getOverlayConfig());\r\n            this.overlayRef.attach(this.getMenuContentPortal());\r\n            this._subscribeToOutsideClicks();\r\n        }\r\n    }\r\n    /** Close the opened menu. */\r\n    close() {\r\n        if (this.isOpen()) {\r\n            this.closed.next();\r\n            this.overlayRef.detach();\r\n        }\r\n        this._closeSiblingTriggers();\r\n    }\r\n    /**\r\n     * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\r\n     */\r\n    getMenu() {\r\n        return this.childMenu;\r\n    }\r\n    /**\r\n     * Handles keyboard events for the menu item.\r\n     * @param event The keyboard event to handle\r\n     */\r\n    _toggleOnKeydown(event) {\r\n        const isParentVertical = this._parentMenu?.orientation === 'vertical';\r\n        switch (event.keyCode) {\r\n            case SPACE:\r\n            case ENTER:\r\n                if (!hasModifierKey(event)) {\r\n                    this.toggle();\r\n                    this.childMenu?.focusFirstItem('keyboard');\r\n                }\r\n                break;\r\n            case RIGHT_ARROW:\r\n                if (!hasModifierKey(event)) {\r\n                    if (this._parentMenu && isParentVertical && this._directionality?.value !== 'rtl') {\r\n                        event.preventDefault();\r\n                        this.open();\r\n                        this.childMenu?.focusFirstItem('keyboard');\r\n                    }\r\n                }\r\n                break;\r\n            case LEFT_ARROW:\r\n                if (!hasModifierKey(event)) {\r\n                    if (this._parentMenu && isParentVertical && this._directionality?.value === 'rtl') {\r\n                        event.preventDefault();\r\n                        this.open();\r\n                        this.childMenu?.focusFirstItem('keyboard');\r\n                    }\r\n                }\r\n                break;\r\n            case DOWN_ARROW:\r\n            case UP_ARROW:\r\n                if (!hasModifierKey(event)) {\r\n                    if (!isParentVertical) {\r\n                        event.preventDefault();\r\n                        this.open();\r\n                        event.keyCode === DOWN_ARROW\r\n                            ? this.childMenu?.focusFirstItem('keyboard')\r\n                            : this.childMenu?.focusLastItem('keyboard');\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    /** Handles clicks on the menu trigger. */\r\n    _handleClick() {\r\n        // Don't handle clicks originating from the keyboard since we\r\n        // already do the same on `keydown` events for enter and space.\r\n        if (this._inputModalityDetector.mostRecentModality !== 'keyboard') {\r\n            this.toggle();\r\n        }\r\n    }\r\n    /**\r\n     * Sets whether the trigger's menu stack has focus.\r\n     * @param hasFocus Whether the menu stack has focus.\r\n     */\r\n    _setHasFocus(hasFocus) {\r\n        if (!this._parentMenu) {\r\n            this.menuStack.setHasFocus(hasFocus);\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\r\n     * into.\r\n     */\r\n    _subscribeToMouseEnter() {\r\n        this._ngZone.runOutsideAngular(() => {\r\n            fromEvent(this._elementRef.nativeElement, 'mouseenter')\r\n                .pipe(filter(() => !this.menuStack.isEmpty() && !this.isOpen()), takeUntil(this.destroyed))\r\n                .subscribe(() => {\r\n                // Closes any sibling menu items and opens the menu associated with this trigger.\r\n                const toggleMenus = () => this._ngZone.run(() => {\r\n                    this._closeSiblingTriggers();\r\n                    this.open();\r\n                });\r\n                if (this._menuAim) {\r\n                    this._menuAim.toggle(toggleMenus);\r\n                }\r\n                else {\r\n                    toggleMenus();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /** Close out any sibling menu trigger menus. */\r\n    _closeSiblingTriggers() {\r\n        if (this._parentMenu) {\r\n            // If nothing was removed from the stack and the last element is not the parent item\r\n            // that means that the parent menu is a menu bar since we don't put the menu bar on the\r\n            // stack\r\n            const isParentMenuBar = !this.menuStack.closeSubMenuOf(this._parentMenu) &&\r\n                this.menuStack.peek() !== this._parentMenu;\r\n            if (isParentMenuBar) {\r\n                this.menuStack.closeAll();\r\n            }\r\n        }\r\n        else {\r\n            this.menuStack.closeAll();\r\n        }\r\n    }\r\n    /** Get the configuration object used to create the overlay. */\r\n    _getOverlayConfig() {\r\n        return new OverlayConfig({\r\n            positionStrategy: this._getOverlayPositionStrategy(),\r\n            scrollStrategy: this._overlay.scrollStrategies.reposition(),\r\n            direction: this._directionality || undefined,\r\n        });\r\n    }\r\n    /** Build the position strategy for the overlay which specifies where to place the menu. */\r\n    _getOverlayPositionStrategy() {\r\n        return this._overlay\r\n            .position()\r\n            .flexibleConnectedTo(this._elementRef)\r\n            .withLockedPosition()\r\n            .withGrowAfterOpen()\r\n            .withPositions(this._getOverlayPositions());\r\n    }\r\n    /** Get the preferred positions for the opened menu relative to the menu item. */\r\n    _getOverlayPositions() {\r\n        return (this.menuPosition ??\r\n            (!this._parentMenu || this._parentMenu.orientation === 'horizontal'\r\n                ? STANDARD_DROPDOWN_BELOW_POSITIONS\r\n                : STANDARD_DROPDOWN_ADJACENT_POSITIONS));\r\n    }\r\n    /**\r\n     * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\r\n     * this triggers when requested.\r\n     */\r\n    _registerCloseHandler() {\r\n        if (!this._parentMenu) {\r\n            this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({ item }) => {\r\n                if (item === this.childMenu) {\r\n                    this.close();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\r\n     * click occurs outside the menus.\r\n     */\r\n    _subscribeToOutsideClicks() {\r\n        if (this.overlayRef) {\r\n            this.overlayRef\r\n                .outsidePointerEvents()\r\n                .pipe(takeUntil(this.stopOutsideClicksListener))\r\n                .subscribe(event => {\r\n                const target = _getEventTarget(event);\r\n                const element = this._elementRef.nativeElement;\r\n                if (target !== element && !element.contains(target)) {\r\n                    if (!this.isElementInsideMenuStack(target)) {\r\n                        this.menuStack.closeAll();\r\n                    }\r\n                    else {\r\n                        this._closeSiblingTriggers();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** Subscribe to the MenuStack hasFocus events. */\r\n    _subscribeToMenuStackHasFocus() {\r\n        if (!this._parentMenu) {\r\n            this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\r\n                if (!hasFocus) {\r\n                    this.menuStack.closeAll();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** Subscribe to the MenuStack closed events. */\r\n    _subscribeToMenuStackClosed() {\r\n        if (!this._parentMenu) {\r\n            this.menuStack.closed.subscribe(({ focusParentTrigger }) => {\r\n                if (focusParentTrigger && !this.menuStack.length()) {\r\n                    this._elementRef.nativeElement.focus();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** Sets the role attribute for this trigger if needed. */\r\n    _setRole() {\r\n        // If this trigger is part of another menu, the cdkMenuItem directive will handle setting the\r\n        // role, otherwise this is a standalone trigger, and we should ensure it has role=\"button\".\r\n        if (!this._parentMenu) {\r\n            this._elementRef.nativeElement.setAttribute('role', 'button');\r\n        }\r\n    }\r\n    /** Sets thte `type` attribute of the trigger. */\r\n    _setType() {\r\n        const element = this._elementRef.nativeElement;\r\n        if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\r\n            // Prevents form submissions.\r\n            element.setAttribute('type', 'button');\r\n        }\r\n    }\r\n}\r\nCdkMenuTrigger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuTrigger.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuTrigger, isStandalone: true, selector: \"[cdkMenuTriggerFor]\", inputs: { menuTemplateRef: [\"cdkMenuTriggerFor\", \"menuTemplateRef\"], menuPosition: [\"cdkMenuPosition\", \"menuPosition\"], menuData: [\"cdkMenuTriggerData\", \"menuData\"] }, outputs: { opened: \"cdkMenuOpened\", closed: \"cdkMenuClosed\" }, host: { listeners: { \"focusin\": \"_setHasFocus(true)\", \"focusout\": \"_setHasFocus(false)\", \"keydown\": \"_toggleOnKeydown($event)\", \"click\": \"_handleClick()\" }, properties: { \"attr.aria-haspopup\": \"menuTemplateRef ? \\\"menu\\\" : null\", \"attr.aria-expanded\": \"menuTemplateRef == null ? null : isOpen()\" }, classAttribute: \"cdk-menu-trigger\" }, providers: [\r\n        { provide: MENU_TRIGGER, useExisting: CdkMenuTrigger },\r\n        PARENT_OR_NEW_MENU_STACK_PROVIDER,\r\n    ], exportAs: [\"cdkMenuTriggerFor\"], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuTrigger, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMenuTriggerFor]',\r\n                    exportAs: 'cdkMenuTriggerFor',\r\n                    standalone: true,\r\n                    host: {\r\n                        'class': 'cdk-menu-trigger',\r\n                        '[attr.aria-haspopup]': 'menuTemplateRef ? \"menu\" : null',\r\n                        '[attr.aria-expanded]': 'menuTemplateRef == null ? null : isOpen()',\r\n                        '(focusin)': '_setHasFocus(true)',\r\n                        '(focusout)': '_setHasFocus(false)',\r\n                        '(keydown)': '_toggleOnKeydown($event)',\r\n                        '(click)': '_handleClick()',\r\n                    },\r\n                    inputs: [\r\n                        'menuTemplateRef: cdkMenuTriggerFor',\r\n                        'menuPosition: cdkMenuPosition',\r\n                        'menuData: cdkMenuTriggerData',\r\n                    ],\r\n                    outputs: ['opened: cdkMenuOpened', 'closed: cdkMenuClosed'],\r\n                    providers: [\r\n                        { provide: MENU_TRIGGER, useExisting: CdkMenuTrigger },\r\n                        PARENT_OR_NEW_MENU_STACK_PROVIDER,\r\n                    ],\r\n                }]\r\n        }], ctorParameters: function () { return []; } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Directive which provides the ability for an element to be focused and navigated to using the\r\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\r\n * behavior when clicked.\r\n */\r\nclass CdkMenuItem {\r\n    /**  Whether the CdkMenuItem is disabled - defaults to false */\r\n    get disabled() {\r\n        return this._disabled;\r\n    }\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n    }\r\n    /** Whether the menu item opens a menu. */\r\n    get hasMenu() {\r\n        return this._menuTrigger?.menuTemplateRef != null;\r\n    }\r\n    constructor() {\r\n        this._dir = inject(Directionality, { optional: true });\r\n        this._inputModalityDetector = inject(InputModalityDetector);\r\n        this._elementRef = inject(ElementRef);\r\n        this._ngZone = inject(NgZone);\r\n        /** The menu aim service used by this menu. */\r\n        this._menuAim = inject(MENU_AIM, { optional: true });\r\n        /** The stack of menus this menu belongs to. */\r\n        this._menuStack = inject(MENU_STACK);\r\n        /** The parent menu in which this menuitem resides. */\r\n        this._parentMenu = inject(CDK_MENU, { optional: true });\r\n        /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\r\n        this._menuTrigger = inject(CdkMenuTrigger, { optional: true, self: true });\r\n        this._disabled = false;\r\n        /**\r\n         * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\r\n         * event.\r\n         */\r\n        this.triggered = new EventEmitter();\r\n        /**\r\n         * The tabindex for this menu item managed internally and used for implementing roving a\r\n         * tab index.\r\n         */\r\n        this._tabindex = -1;\r\n        /** Whether the item should close the menu if triggered by the spacebar. */\r\n        this.closeOnSpacebarTrigger = true;\r\n        /** Emits when the menu item is destroyed. */\r\n        this.destroyed = new Subject();\r\n        this._setupMouseEnter();\r\n        this._setType();\r\n        if (this._isStandaloneItem()) {\r\n            this._tabindex = 0;\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this.destroyed.next();\r\n        this.destroyed.complete();\r\n    }\r\n    /** Place focus on the element. */\r\n    focus() {\r\n        this._elementRef.nativeElement.focus();\r\n    }\r\n    /**\r\n     * If the menu item is not disabled and the element does not have a menu trigger attached, emit\r\n     * on the cdkMenuItemTriggered emitter and close all open menus.\r\n     * @param options Options the configure how the item is triggered\r\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\r\n     */\r\n    trigger(options) {\r\n        const { keepOpen } = { ...options };\r\n        if (!this.disabled && !this.hasMenu) {\r\n            this.triggered.next();\r\n            if (!keepOpen) {\r\n                this._menuStack.closeAll({ focusParentTrigger: true });\r\n            }\r\n        }\r\n    }\r\n    /** Return true if this MenuItem has an attached menu and it is open. */\r\n    isMenuOpen() {\r\n        return !!this._menuTrigger?.isOpen();\r\n    }\r\n    /**\r\n     * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\r\n     * @return the menu if it is open, otherwise undefined.\r\n     */\r\n    getMenu() {\r\n        return this._menuTrigger?.getMenu();\r\n    }\r\n    /** Get the CdkMenuTrigger associated with this element. */\r\n    getMenuTrigger() {\r\n        return this._menuTrigger;\r\n    }\r\n    /** Get the label for this element which is required by the FocusableOption interface. */\r\n    getLabel() {\r\n        return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\r\n    }\r\n    /** Reset the tabindex to -1. */\r\n    _resetTabIndex() {\r\n        if (!this._isStandaloneItem()) {\r\n            this._tabindex = -1;\r\n        }\r\n    }\r\n    /**\r\n     * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\r\n     * is not in a menu bar.\r\n     */\r\n    _setTabIndex(event) {\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n        // don't set the tabindex if there are no open sibling or parent menus\r\n        if (!event || !this._menuStack.isEmpty()) {\r\n            this._tabindex = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Handles keyboard events for the menu item, specifically either triggering the user defined\r\n     * callback or opening/closing the current menu based on whether the left or right arrow key was\r\n     * pressed.\r\n     * @param event the keyboard event to handle\r\n     */\r\n    _onKeydown(event) {\r\n        switch (event.keyCode) {\r\n            case SPACE:\r\n            case ENTER:\r\n                if (!hasModifierKey(event)) {\r\n                    this.trigger({ keepOpen: event.keyCode === SPACE && !this.closeOnSpacebarTrigger });\r\n                }\r\n                break;\r\n            case RIGHT_ARROW:\r\n                if (!hasModifierKey(event)) {\r\n                    if (this._parentMenu && this._isParentVertical()) {\r\n                        if (this._dir?.value !== 'rtl') {\r\n                            this._forwardArrowPressed(event);\r\n                        }\r\n                        else {\r\n                            this._backArrowPressed(event);\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case LEFT_ARROW:\r\n                if (!hasModifierKey(event)) {\r\n                    if (this._parentMenu && this._isParentVertical()) {\r\n                        if (this._dir?.value !== 'rtl') {\r\n                            this._backArrowPressed(event);\r\n                        }\r\n                        else {\r\n                            this._forwardArrowPressed(event);\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    /** Handles clicks on the menu item. */\r\n    _handleClick() {\r\n        // Don't handle clicks originating from the keyboard since we\r\n        // already do the same on `keydown` events for enter and space.\r\n        if (this._inputModalityDetector.mostRecentModality !== 'keyboard') {\r\n            this.trigger();\r\n        }\r\n    }\r\n    /** Whether this menu item is standalone or within a menu or menu bar. */\r\n    _isStandaloneItem() {\r\n        return !this._parentMenu;\r\n    }\r\n    /**\r\n     * Handles the user pressing the back arrow key.\r\n     * @param event The keyboard event.\r\n     */\r\n    _backArrowPressed(event) {\r\n        const parentMenu = this._parentMenu;\r\n        if (this._menuStack.hasInlineMenu() || this._menuStack.length() > 1) {\r\n            event.preventDefault();\r\n            this._menuStack.close(parentMenu, {\r\n                focusNextOnEmpty: this._menuStack.inlineMenuOrientation() === 'horizontal'\r\n                    ? 1 /* FocusNext.previousItem */\r\n                    : 2 /* FocusNext.currentItem */,\r\n                focusParentTrigger: true,\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Handles the user pressing the forward arrow key.\r\n     * @param event The keyboard event.\r\n     */\r\n    _forwardArrowPressed(event) {\r\n        if (!this.hasMenu && this._menuStack.inlineMenuOrientation() === 'horizontal') {\r\n            event.preventDefault();\r\n            this._menuStack.closeAll({\r\n                focusNextOnEmpty: 0 /* FocusNext.nextItem */,\r\n                focusParentTrigger: true,\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\r\n     * into.\r\n     */\r\n    _setupMouseEnter() {\r\n        if (!this._isStandaloneItem()) {\r\n            const closeOpenSiblings = () => this._ngZone.run(() => this._menuStack.closeSubMenuOf(this._parentMenu));\r\n            this._ngZone.runOutsideAngular(() => fromEvent(this._elementRef.nativeElement, 'mouseenter')\r\n                .pipe(filter(() => !this._menuStack.isEmpty() && !this.hasMenu), takeUntil(this.destroyed))\r\n                .subscribe(() => {\r\n                if (this._menuAim) {\r\n                    this._menuAim.toggle(closeOpenSiblings);\r\n                }\r\n                else {\r\n                    closeOpenSiblings();\r\n                }\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Return true if the enclosing parent menu is configured in a horizontal orientation, false\r\n     * otherwise or if no parent.\r\n     */\r\n    _isParentVertical() {\r\n        return this._parentMenu?.orientation === 'vertical';\r\n    }\r\n    /** Sets the `type` attribute of the menu item. */\r\n    _setType() {\r\n        const element = this._elementRef.nativeElement;\r\n        if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\r\n            // Prevent form submissions.\r\n            element.setAttribute('type', 'button');\r\n        }\r\n    }\r\n}\r\nCdkMenuItem.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItem, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuItem.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuItem, isStandalone: true, selector: \"[cdkMenuItem]\", inputs: { disabled: [\"cdkMenuItemDisabled\", \"disabled\"], typeaheadLabel: [\"cdkMenuitemTypeaheadLabel\", \"typeaheadLabel\"] }, outputs: { triggered: \"cdkMenuItemTriggered\" }, host: { attributes: { \"role\": \"menuitem\" }, listeners: { \"blur\": \"_resetTabIndex()\", \"focus\": \"_setTabIndex()\", \"click\": \"_handleClick()\", \"keydown\": \"_onKeydown($event)\" }, properties: { \"tabindex\": \"_tabindex\", \"attr.aria-disabled\": \"disabled || null\" }, classAttribute: \"cdk-menu-item\" }, exportAs: [\"cdkMenuItem\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItem, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMenuItem]',\r\n                    exportAs: 'cdkMenuItem',\r\n                    standalone: true,\r\n                    host: {\r\n                        'role': 'menuitem',\r\n                        'class': 'cdk-menu-item',\r\n                        '[tabindex]': '_tabindex',\r\n                        '[attr.aria-disabled]': 'disabled || null',\r\n                        '(blur)': '_resetTabIndex()',\r\n                        '(focus)': '_setTabIndex()',\r\n                        '(click)': '_handleClick()',\r\n                        '(keydown)': '_onKeydown($event)',\r\n                    },\r\n                }]\r\n        }], ctorParameters: function () { return []; }, propDecorators: { disabled: [{\r\n                type: Input,\r\n                args: ['cdkMenuItemDisabled']\r\n            }], typeaheadLabel: [{\r\n                type: Input,\r\n                args: ['cdkMenuitemTypeaheadLabel']\r\n            }], triggered: [{\r\n                type: Output,\r\n                args: ['cdkMenuItemTriggered']\r\n            }] } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\r\n * observables which emit when the users mouse enters and leaves a tracked element.\r\n */\r\nclass PointerFocusTracker {\r\n    constructor(\r\n    /** The list of items being tracked. */\r\n    _items) {\r\n        this._items = _items;\r\n        /** Emits when an element is moused into. */\r\n        this.entered = this._getItemPointerEntries();\r\n        /** Emits when an element is moused out. */\r\n        this.exited = this._getItemPointerExits();\r\n        /** Emits when this is destroyed. */\r\n        this._destroyed = new Subject();\r\n        this.entered.subscribe(element => (this.activeElement = element));\r\n        this.exited.subscribe(() => {\r\n            this.previousElement = this.activeElement;\r\n            this.activeElement = undefined;\r\n        });\r\n    }\r\n    /** Stop the managers listeners. */\r\n    destroy() {\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /**\r\n     * Gets a stream of pointer (mouse) entries into the given items.\r\n     * This should typically run outside the Angular zone.\r\n     */\r\n    _getItemPointerEntries() {\r\n        return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap((list) => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseenter').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\r\n    }\r\n    /**\r\n     * Gets a stream of pointer (mouse) exits out of the given items.\r\n     * This should typically run outside the Angular zone.\r\n     */\r\n    _getItemPointerExits() {\r\n        return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap((list) => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseout').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Counter used to create unique IDs for menus. */\r\nlet nextId$1 = 0;\r\n/**\r\n * Abstract directive that implements shared logic common to all menus.\r\n * This class can be extended to create custom menu types.\r\n */\r\nclass CdkMenuBase extends CdkMenuGroup {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** The menu's native DOM host element. */\r\n        this.nativeElement = inject(ElementRef).nativeElement;\r\n        /** The Angular zone. */\r\n        this.ngZone = inject(NgZone);\r\n        /** The stack of menus this menu belongs to. */\r\n        this.menuStack = inject(MENU_STACK);\r\n        /** The menu aim service used by this menu. */\r\n        this.menuAim = inject(MENU_AIM, { optional: true, self: true });\r\n        /** The directionality (text direction) of the current page. */\r\n        this.dir = inject(Directionality, { optional: true });\r\n        /** The id of the menu's host element. */\r\n        this.id = `cdk-menu-${nextId$1++}`;\r\n        /** The direction items in the menu flow. */\r\n        this.orientation = 'vertical';\r\n        /**\r\n         * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\r\n         * user triggers with a trigger element).\r\n         */\r\n        this.isInline = false;\r\n        /** Emits when the MenuBar is destroyed. */\r\n        this.destroyed = new Subject();\r\n        /** Whether this menu's menu stack has focus. */\r\n        this._menuStackHasFocus = false;\r\n    }\r\n    ngAfterContentInit() {\r\n        if (!this.isInline) {\r\n            this.menuStack.push(this);\r\n        }\r\n        this._setKeyManager();\r\n        this._subscribeToMenuStackHasFocus();\r\n        this._subscribeToMenuOpen();\r\n        this._subscribeToMenuStackClosed();\r\n        this._setUpPointerTracker();\r\n    }\r\n    ngOnDestroy() {\r\n        this.keyManager?.destroy();\r\n        this.destroyed.next();\r\n        this.destroyed.complete();\r\n        this.pointerTracker?.destroy();\r\n    }\r\n    /**\r\n     * Place focus on the first MenuItem in the menu and set the focus origin.\r\n     * @param focusOrigin The origin input mode of the focus event.\r\n     */\r\n    focusFirstItem(focusOrigin = 'program') {\r\n        this.keyManager.setFocusOrigin(focusOrigin);\r\n        this.keyManager.setFirstItemActive();\r\n    }\r\n    /**\r\n     * Place focus on the last MenuItem in the menu and set the focus origin.\r\n     * @param focusOrigin The origin input mode of the focus event.\r\n     */\r\n    focusLastItem(focusOrigin = 'program') {\r\n        this.keyManager.setFocusOrigin(focusOrigin);\r\n        this.keyManager.setLastItemActive();\r\n    }\r\n    /** Gets the tabindex for this menu. */\r\n    _getTabIndex() {\r\n        const tabindexIfInline = this._menuStackHasFocus ? -1 : 0;\r\n        return this.isInline ? tabindexIfInline : null;\r\n    }\r\n    /**\r\n     * Close the open menu if the current active item opened the requested MenuStackItem.\r\n     * @param menu The menu requested to be closed.\r\n     * @param options Options to configure the behavior on close.\r\n     *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\r\n     */\r\n    closeOpenMenu(menu, options) {\r\n        const { focusParentTrigger } = { ...options };\r\n        const keyManager = this.keyManager;\r\n        const trigger = this.triggerItem;\r\n        if (menu === trigger?.getMenuTrigger()?.getMenu()) {\r\n            trigger?.getMenuTrigger()?.close();\r\n            // If the user has moused over a sibling item we want to focus the element under mouse focus\r\n            // not the trigger which previously opened the now closed menu.\r\n            if (focusParentTrigger) {\r\n                if (trigger) {\r\n                    keyManager.setActiveItem(trigger);\r\n                }\r\n                else {\r\n                    keyManager.setFirstItemActive();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Setup the FocusKeyManager with the correct orientation for the menu. */\r\n    _setKeyManager() {\r\n        this.keyManager = new FocusKeyManager(this.items).withWrap().withTypeAhead().withHomeAndEnd();\r\n        if (this.orientation === 'horizontal') {\r\n            this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');\r\n        }\r\n        else {\r\n            this.keyManager.withVerticalOrientation();\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\r\n     * and stop tracking it when the menu is closed.\r\n     */\r\n    _subscribeToMenuOpen() {\r\n        const exitCondition = merge(this.items.changes, this.destroyed);\r\n        this.items.changes\r\n            .pipe(startWith(this.items), mergeMap((list) => list\r\n            .filter(item => item.hasMenu)\r\n            .map(item => item.getMenuTrigger().opened.pipe(mapTo(item), takeUntil(exitCondition)))), mergeAll(), switchMap((item) => {\r\n            this.triggerItem = item;\r\n            return item.getMenuTrigger().closed;\r\n        }), takeUntil(this.destroyed))\r\n            .subscribe(() => (this.triggerItem = undefined));\r\n    }\r\n    /** Subscribe to the MenuStack close events. */\r\n    _subscribeToMenuStackClosed() {\r\n        this.menuStack.closed\r\n            .pipe(takeUntil(this.destroyed))\r\n            .subscribe(({ item, focusParentTrigger }) => this.closeOpenMenu(item, { focusParentTrigger }));\r\n    }\r\n    /** Subscribe to the MenuStack hasFocus events. */\r\n    _subscribeToMenuStackHasFocus() {\r\n        if (this.isInline) {\r\n            this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\r\n                this._menuStackHasFocus = hasFocus;\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\r\n     * with the latest menu item under mouse focus.\r\n     */\r\n    _setUpPointerTracker() {\r\n        if (this.menuAim) {\r\n            this.ngZone.runOutsideAngular(() => {\r\n                this.pointerTracker = new PointerFocusTracker(this.items);\r\n            });\r\n            this.menuAim.initialize(this, this.pointerTracker);\r\n        }\r\n    }\r\n}\r\nCdkMenuBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuBase, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuBase, inputs: { id: \"id\" }, host: { attributes: { \"role\": \"menu\" }, listeners: { \"focus\": \"focusFirstItem()\", \"focusin\": \"menuStack.setHasFocus(true)\", \"focusout\": \"menuStack.setHasFocus(false)\" }, properties: { \"tabindex\": \"_getTabIndex()\", \"id\": \"id\", \"attr.aria-orientation\": \"orientation\", \"attr.data-cdk-menu-stack-id\": \"menuStack.id\" } }, queries: [{ propertyName: \"items\", predicate: CdkMenuItem, descendants: true }], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuBase, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    host: {\r\n                        'role': 'menu',\r\n                        'class': '',\r\n                        '[tabindex]': '_getTabIndex()',\r\n                        '[id]': 'id',\r\n                        '[attr.aria-orientation]': 'orientation',\r\n                        '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\r\n                        '(focus)': 'focusFirstItem()',\r\n                        '(focusin)': 'menuStack.setHasFocus(true)',\r\n                        '(focusout)': 'menuStack.setHasFocus(false)',\r\n                    },\r\n                }]\r\n        }], propDecorators: { id: [{\r\n                type: Input\r\n            }], items: [{\r\n                type: ContentChildren,\r\n                args: [CdkMenuItem, { descendants: true }]\r\n            }] } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Directive which configures the element as a Menu which should contain child elements marked as\r\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\r\n * contains accessible keyboard and mouse handling logic.\r\n *\r\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\r\n */\r\nclass CdkMenu extends CdkMenuBase {\r\n    constructor() {\r\n        super();\r\n        this._parentTrigger = inject(MENU_TRIGGER, { optional: true });\r\n        /** Event emitted when the menu is closed. */\r\n        this.closed = new EventEmitter();\r\n        /** The direction items in the menu flow. */\r\n        this.orientation = 'vertical';\r\n        /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\r\n        this.isInline = !this._parentTrigger;\r\n        this.destroyed.subscribe(this.closed);\r\n        this._parentTrigger?.registerChildMenu(this);\r\n    }\r\n    ngAfterContentInit() {\r\n        super.ngAfterContentInit();\r\n        this._subscribeToMenuStackEmptied();\r\n    }\r\n    ngOnDestroy() {\r\n        super.ngOnDestroy();\r\n        this.closed.complete();\r\n    }\r\n    /**\r\n     * Handle keyboard events for the Menu.\r\n     * @param event The keyboard event to be handled.\r\n     */\r\n    _handleKeyEvent(event) {\r\n        const keyManager = this.keyManager;\r\n        switch (event.keyCode) {\r\n            case LEFT_ARROW:\r\n            case RIGHT_ARROW:\r\n                if (!hasModifierKey(event)) {\r\n                    event.preventDefault();\r\n                    keyManager.setFocusOrigin('keyboard');\r\n                    keyManager.onKeydown(event);\r\n                }\r\n                break;\r\n            case ESCAPE:\r\n                if (!hasModifierKey(event)) {\r\n                    event.preventDefault();\r\n                    this.menuStack.close(this, {\r\n                        focusNextOnEmpty: 2 /* FocusNext.currentItem */,\r\n                        focusParentTrigger: true,\r\n                    });\r\n                }\r\n                break;\r\n            case TAB:\r\n                if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\r\n                    this.menuStack.closeAll({ focusParentTrigger: true });\r\n                }\r\n                break;\r\n            default:\r\n                keyManager.onKeydown(event);\r\n        }\r\n    }\r\n    /**\r\n     * Set focus the either the current, previous or next item based on the FocusNext event.\r\n     * @param focusNext The element to focus.\r\n     */\r\n    _toggleMenuFocus(focusNext) {\r\n        const keyManager = this.keyManager;\r\n        switch (focusNext) {\r\n            case 0 /* FocusNext.nextItem */:\r\n                keyManager.setFocusOrigin('keyboard');\r\n                keyManager.setNextItemActive();\r\n                break;\r\n            case 1 /* FocusNext.previousItem */:\r\n                keyManager.setFocusOrigin('keyboard');\r\n                keyManager.setPreviousItemActive();\r\n                break;\r\n            case 2 /* FocusNext.currentItem */:\r\n                if (keyManager.activeItem) {\r\n                    keyManager.setFocusOrigin('keyboard');\r\n                    keyManager.setActiveItem(keyManager.activeItem);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    /** Subscribe to the MenuStack emptied events. */\r\n    _subscribeToMenuStackEmptied() {\r\n        this.menuStack.emptied\r\n            .pipe(takeUntil(this.destroyed))\r\n            .subscribe(event => this._toggleMenuFocus(event));\r\n    }\r\n}\r\nCdkMenu.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenu, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenu.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenu, isStandalone: true, selector: \"[cdkMenu]\", outputs: { closed: \"closed\" }, host: { attributes: { \"role\": \"menu\" }, listeners: { \"keydown\": \"_handleKeyEvent($event)\" }, properties: { \"class.cdk-menu-inline\": \"isInline\" }, classAttribute: \"cdk-menu\" }, providers: [\r\n        { provide: CdkMenuGroup, useExisting: CdkMenu },\r\n        { provide: CDK_MENU, useExisting: CdkMenu },\r\n        PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical'),\r\n    ], exportAs: [\"cdkMenu\"], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenu, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMenu]',\r\n                    exportAs: 'cdkMenu',\r\n                    standalone: true,\r\n                    host: {\r\n                        'role': 'menu',\r\n                        'class': 'cdk-menu',\r\n                        '[class.cdk-menu-inline]': 'isInline',\r\n                        '(keydown)': '_handleKeyEvent($event)',\r\n                    },\r\n                    providers: [\r\n                        { provide: CdkMenuGroup, useExisting: CdkMenu },\r\n                        { provide: CDK_MENU, useExisting: CdkMenu },\r\n                        PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical'),\r\n                    ],\r\n                }]\r\n        }], ctorParameters: function () { return []; }, propDecorators: { closed: [{\r\n                type: Output\r\n            }] } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\r\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\r\n * this directive is applied to should contain components marked with CdkMenuItem.\r\n *\r\n */\r\nclass CdkMenuBar extends CdkMenuBase {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** The direction items in the menu flow. */\r\n        this.orientation = 'horizontal';\r\n        /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\r\n        this.isInline = true;\r\n    }\r\n    ngAfterContentInit() {\r\n        super.ngAfterContentInit();\r\n        this._subscribeToMenuStackEmptied();\r\n    }\r\n    /**\r\n     * Handle keyboard events for the Menu.\r\n     * @param event The keyboard event to be handled.\r\n     */\r\n    _handleKeyEvent(event) {\r\n        const keyManager = this.keyManager;\r\n        switch (event.keyCode) {\r\n            case UP_ARROW:\r\n            case DOWN_ARROW:\r\n            case LEFT_ARROW:\r\n            case RIGHT_ARROW:\r\n                if (!hasModifierKey(event)) {\r\n                    const horizontalArrows = event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW;\r\n                    // For a horizontal menu if the left/right keys were clicked, or a vertical menu if the\r\n                    // up/down keys were clicked: if the current menu is open, close it then focus and open the\r\n                    // next  menu.\r\n                    if (horizontalArrows) {\r\n                        event.preventDefault();\r\n                        const prevIsOpen = keyManager.activeItem?.isMenuOpen();\r\n                        keyManager.activeItem?.getMenuTrigger()?.close();\r\n                        keyManager.setFocusOrigin('keyboard');\r\n                        keyManager.onKeydown(event);\r\n                        if (prevIsOpen) {\r\n                            keyManager.activeItem?.getMenuTrigger()?.open();\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case ESCAPE:\r\n                if (!hasModifierKey(event)) {\r\n                    event.preventDefault();\r\n                    keyManager.activeItem?.getMenuTrigger()?.close();\r\n                }\r\n                break;\r\n            case TAB:\r\n                if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\r\n                    keyManager.activeItem?.getMenuTrigger()?.close();\r\n                }\r\n                break;\r\n            default:\r\n                keyManager.onKeydown(event);\r\n        }\r\n    }\r\n    /**\r\n     * Set focus to either the current, previous or next item based on the FocusNext event, then\r\n     * open the previous or next item.\r\n     * @param focusNext The element to focus.\r\n     */\r\n    _toggleOpenMenu(focusNext) {\r\n        const keyManager = this.keyManager;\r\n        switch (focusNext) {\r\n            case 0 /* FocusNext.nextItem */:\r\n                keyManager.setFocusOrigin('keyboard');\r\n                keyManager.setNextItemActive();\r\n                keyManager.activeItem?.getMenuTrigger()?.open();\r\n                break;\r\n            case 1 /* FocusNext.previousItem */:\r\n                keyManager.setFocusOrigin('keyboard');\r\n                keyManager.setPreviousItemActive();\r\n                keyManager.activeItem?.getMenuTrigger()?.open();\r\n                break;\r\n            case 2 /* FocusNext.currentItem */:\r\n                if (keyManager.activeItem) {\r\n                    keyManager.setFocusOrigin('keyboard');\r\n                    keyManager.setActiveItem(keyManager.activeItem);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    /** Subscribe to the MenuStack emptied events. */\r\n    _subscribeToMenuStackEmptied() {\r\n        this.menuStack?.emptied\r\n            .pipe(takeUntil(this.destroyed))\r\n            .subscribe(event => this._toggleOpenMenu(event));\r\n    }\r\n}\r\nCdkMenuBar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuBar, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuBar.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuBar, isStandalone: true, selector: \"[cdkMenuBar]\", host: { attributes: { \"role\": \"menubar\" }, listeners: { \"keydown\": \"_handleKeyEvent($event)\" }, classAttribute: \"cdk-menu-bar\" }, providers: [\r\n        { provide: CdkMenuGroup, useExisting: CdkMenuBar },\r\n        { provide: CDK_MENU, useExisting: CdkMenuBar },\r\n        { provide: MENU_STACK, useFactory: () => MenuStack.inline('horizontal') },\r\n    ], exportAs: [\"cdkMenuBar\"], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuBar, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMenuBar]',\r\n                    exportAs: 'cdkMenuBar',\r\n                    standalone: true,\r\n                    host: {\r\n                        'role': 'menubar',\r\n                        'class': 'cdk-menu-bar',\r\n                        '(keydown)': '_handleKeyEvent($event)',\r\n                    },\r\n                    providers: [\r\n                        { provide: CdkMenuGroup, useExisting: CdkMenuBar },\r\n                        { provide: CDK_MENU, useExisting: CdkMenuBar },\r\n                        { provide: MENU_STACK, useFactory: () => MenuStack.inline('horizontal') },\r\n                    ],\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Base class providing checked state for selectable MenuItems. */\r\nclass CdkMenuItemSelectable extends CdkMenuItem {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._checked = false;\r\n        /** Whether the item should close the menu if triggered by the spacebar. */\r\n        this.closeOnSpacebarTrigger = false;\r\n    }\r\n    /** Whether the element is checked */\r\n    get checked() {\r\n        return this._checked;\r\n    }\r\n    set checked(value) {\r\n        this._checked = coerceBooleanProperty(value);\r\n    }\r\n}\r\nCdkMenuItemSelectable.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItemSelectable, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuItemSelectable.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuItemSelectable, inputs: { checked: [\"cdkMenuItemChecked\", \"checked\"] }, host: { properties: { \"attr.aria-checked\": \"!!checked\", \"attr.aria-disabled\": \"disabled || null\" } }, usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItemSelectable, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    host: {\r\n                        '[attr.aria-checked]': '!!checked',\r\n                        '[attr.aria-disabled]': 'disabled || null',\r\n                    },\r\n                }]\r\n        }], propDecorators: { checked: [{\r\n                type: Input,\r\n                args: ['cdkMenuItemChecked']\r\n            }] } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Counter used to set a unique id and name for a selectable item */\r\nlet nextId = 0;\r\n/**\r\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\r\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\r\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\r\n */\r\nclass CdkMenuItemRadio extends CdkMenuItemSelectable {\r\n    constructor() {\r\n        super();\r\n        /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\r\n        this._selectionDispatcher = inject(UniqueSelectionDispatcher);\r\n        /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\r\n        this._id = `${nextId++}`;\r\n        this._registerDispatcherListener();\r\n    }\r\n    ngOnDestroy() {\r\n        super.ngOnDestroy();\r\n        this._removeDispatcherListener();\r\n    }\r\n    /**\r\n     * Toggles the checked state of the radio-button.\r\n     * @param options Options the configure how the item is triggered\r\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\r\n     */\r\n    trigger(options) {\r\n        super.trigger(options);\r\n        if (!this.disabled) {\r\n            this._selectionDispatcher.notify(this._id, '');\r\n        }\r\n    }\r\n    /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\r\n    _registerDispatcherListener() {\r\n        this._removeDispatcherListener = this._selectionDispatcher.listen((id) => {\r\n            this.checked = this._id === id;\r\n        });\r\n    }\r\n}\r\nCdkMenuItemRadio.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItemRadio, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuItemRadio.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuItemRadio, isStandalone: true, selector: \"[cdkMenuItemRadio]\", host: { attributes: { \"role\": \"menuitemradio\" }, properties: { \"class.cdk-menu-item-radio\": \"true\" } }, providers: [\r\n        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemRadio },\r\n        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\r\n    ], exportAs: [\"cdkMenuItemRadio\"], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItemRadio, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMenuItemRadio]',\r\n                    exportAs: 'cdkMenuItemRadio',\r\n                    standalone: true,\r\n                    host: {\r\n                        'role': 'menuitemradio',\r\n                        '[class.cdk-menu-item-radio]': 'true',\r\n                    },\r\n                    providers: [\r\n                        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemRadio },\r\n                        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\r\n                    ],\r\n                }]\r\n        }], ctorParameters: function () { return []; } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\r\n * conventional checkbox.\r\n */\r\nclass CdkMenuItemCheckbox extends CdkMenuItemSelectable {\r\n    /**\r\n     * Toggle the checked state of the checkbox.\r\n     * @param options Options the configure how the item is triggered\r\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\r\n     */\r\n    trigger(options) {\r\n        super.trigger(options);\r\n        if (!this.disabled) {\r\n            this.checked = !this.checked;\r\n        }\r\n    }\r\n}\r\nCdkMenuItemCheckbox.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItemCheckbox, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\nCdkMenuItemCheckbox.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMenuItemCheckbox, isStandalone: true, selector: \"[cdkMenuItemCheckbox]\", host: { attributes: { \"role\": \"menuitemcheckbox\" }, properties: { \"class.cdk-menu-item-checkbox\": \"true\" } }, providers: [\r\n        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemCheckbox },\r\n        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\r\n    ], exportAs: [\"cdkMenuItemCheckbox\"], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuItemCheckbox, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkMenuItemCheckbox]',\r\n                    exportAs: 'cdkMenuItemCheckbox',\r\n                    standalone: true,\r\n                    host: {\r\n                        'role': 'menuitemcheckbox',\r\n                        '[class.cdk-menu-item-checkbox]': 'true',\r\n                    },\r\n                    providers: [\r\n                        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemCheckbox },\r\n                        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\r\n                    ],\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** The preferred menu positions for the context menu. */\r\nconst CONTEXT_MENU_POSITIONS = STANDARD_DROPDOWN_BELOW_POSITIONS.map(position => {\r\n    // In cases where the first menu item in the context menu is a trigger the submenu opens on a\r\n    // hover event. We offset the context menu 2px by default to prevent this from occurring.\r\n    const offsetX = position.overlayX === 'start' ? 2 : -2;\r\n    const offsetY = position.overlayY === 'top' ? 2 : -2;\r\n    return { ...position, offsetX, offsetY };\r\n});\r\n/** Tracks the last open context menu trigger across the entire application. */\r\nclass ContextMenuTracker {\r\n    /**\r\n     * Close the previous open context menu and set the given one as being open.\r\n     * @param trigger The trigger for the currently open Context Menu.\r\n     */\r\n    update(trigger) {\r\n        if (ContextMenuTracker._openContextMenuTrigger !== trigger) {\r\n            ContextMenuTracker._openContextMenuTrigger?.close();\r\n            ContextMenuTracker._openContextMenuTrigger = trigger;\r\n        }\r\n    }\r\n}\r\nContextMenuTracker.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: ContextMenuTracker, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nContextMenuTracker.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: ContextMenuTracker, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: ContextMenuTracker, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\r\n/**\r\n * A directive that opens a menu when a user right-clicks within its host element.\r\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\r\n */\r\nclass CdkContextMenuTrigger extends CdkMenuTriggerBase {\r\n    /** Whether the context menu is disabled. */\r\n    get disabled() {\r\n        return this._disabled;\r\n    }\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n    }\r\n    constructor() {\r\n        super();\r\n        /** The CDK overlay service. */\r\n        this._overlay = inject(Overlay);\r\n        /** The directionality of the page. */\r\n        this._directionality = inject(Directionality, { optional: true });\r\n        /** The app's context menu tracking registry */\r\n        this._contextMenuTracker = inject(ContextMenuTracker);\r\n        this._disabled = false;\r\n        this._setMenuStackCloseListener();\r\n    }\r\n    /**\r\n     * Open the attached menu at the specified location.\r\n     * @param coordinates where to open the context menu\r\n     */\r\n    open(coordinates) {\r\n        this._open(coordinates, false);\r\n    }\r\n    /** Close the currently opened context menu. */\r\n    close() {\r\n        this.menuStack.closeAll();\r\n    }\r\n    /**\r\n     * Open the context menu and closes any previously open menus.\r\n     * @param event the mouse event which opens the context menu.\r\n     */\r\n    _openOnContextMenu(event) {\r\n        if (!this.disabled) {\r\n            // Prevent the native context menu from opening because we're opening a custom one.\r\n            event.preventDefault();\r\n            // Stop event propagation to ensure that only the closest enabled context menu opens.\r\n            // Otherwise, any context menus attached to containing elements would *also* open,\r\n            // resulting in multiple stacked context menus being displayed.\r\n            event.stopPropagation();\r\n            this._contextMenuTracker.update(this);\r\n            this._open({ x: event.clientX, y: event.clientY }, true);\r\n            // A context menu can be triggered via a mouse right click or a keyboard shortcut.\r\n            if (event.button === 2) {\r\n                this.childMenu?.focusFirstItem('mouse');\r\n            }\r\n            else if (event.button === 0) {\r\n                this.childMenu?.focusFirstItem('keyboard');\r\n            }\r\n            else {\r\n                this.childMenu?.focusFirstItem('program');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get the configuration object used to create the overlay.\r\n     * @param coordinates the location to place the opened menu\r\n     */\r\n    _getOverlayConfig(coordinates) {\r\n        return new OverlayConfig({\r\n            positionStrategy: this._getOverlayPositionStrategy(coordinates),\r\n            scrollStrategy: this._overlay.scrollStrategies.reposition(),\r\n            direction: this._directionality || undefined,\r\n        });\r\n    }\r\n    /**\r\n     * Get the position strategy for the overlay which specifies where to place the menu.\r\n     * @param coordinates the location to place the opened menu\r\n     */\r\n    _getOverlayPositionStrategy(coordinates) {\r\n        return this._overlay\r\n            .position()\r\n            .flexibleConnectedTo(coordinates)\r\n            .withLockedPosition()\r\n            .withGrowAfterOpen()\r\n            .withPositions(this.menuPosition ?? CONTEXT_MENU_POSITIONS);\r\n    }\r\n    /** Subscribe to the menu stack close events and close this menu when requested. */\r\n    _setMenuStackCloseListener() {\r\n        this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({ item }) => {\r\n            if (item === this.childMenu && this.isOpen()) {\r\n                this.closed.next();\r\n                this.overlayRef.detach();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\r\n     * click occurs outside the menus.\r\n     * @param ignoreFirstAuxClick Whether to ignore the first auxclick event outside the menu.\r\n     */\r\n    _subscribeToOutsideClicks(ignoreFirstAuxClick) {\r\n        if (this.overlayRef) {\r\n            let outsideClicks = this.overlayRef.outsidePointerEvents();\r\n            // If the menu was triggered by the `contextmenu` event, skip the first `auxclick` event\r\n            // because it fires when the mouse is released on the same click that opened the menu.\r\n            if (ignoreFirstAuxClick) {\r\n                const [auxClicks, nonAuxClicks] = partition(outsideClicks, ({ type }) => type === 'auxclick');\r\n                outsideClicks = merge(nonAuxClicks, auxClicks.pipe(skip(1)));\r\n            }\r\n            outsideClicks.pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\r\n                if (!this.isElementInsideMenuStack(_getEventTarget(event))) {\r\n                    this.menuStack.closeAll();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Open the attached menu at the specified location.\r\n     * @param coordinates where to open the context menu\r\n     * @param ignoreFirstOutsideAuxClick Whether to ignore the first auxclick outside the menu after opening.\r\n     */\r\n    _open(coordinates, ignoreFirstOutsideAuxClick) {\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n        if (this.isOpen()) {\r\n            // since we're moving this menu we need to close any submenus first otherwise they end up\r\n            // disconnected from this one.\r\n            this.menuStack.closeSubMenuOf(this.childMenu);\r\n            this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\r\n            this.overlayRef.updatePosition();\r\n        }\r\n        else {\r\n            this.opened.next();\r\n            if (this.overlayRef) {\r\n                this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\r\n                this.overlayRef.updatePosition();\r\n            }\r\n            else {\r\n                this.overlayRef = this._overlay.create(this._getOverlayConfig(coordinates));\r\n            }\r\n            this.overlayRef.attach(this.getMenuContentPortal());\r\n            this._subscribeToOutsideClicks(ignoreFirstOutsideAuxClick);\r\n        }\r\n    }\r\n}\r\nCdkContextMenuTrigger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkContextMenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\nCdkContextMenuTrigger.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkContextMenuTrigger, isStandalone: true, selector: \"[cdkContextMenuTriggerFor]\", inputs: { menuTemplateRef: [\"cdkContextMenuTriggerFor\", \"menuTemplateRef\"], menuPosition: [\"cdkContextMenuPosition\", \"menuPosition\"], menuData: [\"cdkContextMenuTriggerData\", \"menuData\"], disabled: [\"cdkContextMenuDisabled\", \"disabled\"] }, outputs: { opened: \"cdkContextMenuOpened\", closed: \"cdkContextMenuClosed\" }, host: { listeners: { \"contextmenu\": \"_openOnContextMenu($event)\" }, properties: { \"attr.data-cdk-menu-stack-id\": \"null\" } }, providers: [\r\n        { provide: MENU_TRIGGER, useExisting: CdkContextMenuTrigger },\r\n        { provide: MENU_STACK, useClass: MenuStack },\r\n    ], exportAs: [\"cdkContextMenuTriggerFor\"], usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkContextMenuTrigger, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[cdkContextMenuTriggerFor]',\r\n                    exportAs: 'cdkContextMenuTriggerFor',\r\n                    standalone: true,\r\n                    host: {\r\n                        '[attr.data-cdk-menu-stack-id]': 'null',\r\n                        '(contextmenu)': '_openOnContextMenu($event)',\r\n                    },\r\n                    inputs: [\r\n                        'menuTemplateRef: cdkContextMenuTriggerFor',\r\n                        'menuPosition: cdkContextMenuPosition',\r\n                        'menuData: cdkContextMenuTriggerData',\r\n                    ],\r\n                    outputs: ['opened: cdkContextMenuOpened', 'closed: cdkContextMenuClosed'],\r\n                    providers: [\r\n                        { provide: MENU_TRIGGER, useExisting: CdkContextMenuTrigger },\r\n                        { provide: MENU_STACK, useClass: MenuStack },\r\n                    ],\r\n                }]\r\n        }], ctorParameters: function () { return []; }, propDecorators: { disabled: [{\r\n                type: Input,\r\n                args: ['cdkContextMenuDisabled']\r\n            }] } });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst MENU_DIRECTIVES = [\r\n    CdkMenuBar,\r\n    CdkMenu,\r\n    CdkMenuItem,\r\n    CdkMenuItemRadio,\r\n    CdkMenuItemCheckbox,\r\n    CdkMenuTrigger,\r\n    CdkMenuGroup,\r\n    CdkContextMenuTrigger,\r\n    CdkTargetMenuAim,\r\n];\r\n/** Module that declares components and directives for the CDK menu. */\r\nclass CdkMenuModule {\r\n}\r\nCdkMenuModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nCdkMenuModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuModule, imports: [OverlayModule, CdkMenuBar,\r\n        CdkMenu,\r\n        CdkMenuItem,\r\n        CdkMenuItemRadio,\r\n        CdkMenuItemCheckbox,\r\n        CdkMenuTrigger,\r\n        CdkMenuGroup,\r\n        CdkContextMenuTrigger,\r\n        CdkTargetMenuAim], exports: [CdkMenuBar,\r\n        CdkMenu,\r\n        CdkMenuItem,\r\n        CdkMenuItemRadio,\r\n        CdkMenuItemCheckbox,\r\n        CdkMenuTrigger,\r\n        CdkMenuGroup,\r\n        CdkContextMenuTrigger,\r\n        CdkTargetMenuAim] });\r\nCdkMenuModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuModule, imports: [OverlayModule] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: i0, type: CdkMenuModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [OverlayModule, ...MENU_DIRECTIVES],\r\n                    exports: MENU_DIRECTIVES,\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { CDK_MENU, CdkContextMenuTrigger, CdkMenu, CdkMenuBar, CdkMenuBase, CdkMenuGroup, CdkMenuItem, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItemSelectable, CdkMenuModule, CdkMenuTrigger, CdkMenuTriggerBase, CdkTargetMenuAim, ContextMenuTracker, MENU_AIM, MENU_STACK, MENU_TRIGGER, MenuStack, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER, PARENT_OR_NEW_MENU_STACK_PROVIDER, PointerFocusTracker, TargetMenuAim };\r\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}